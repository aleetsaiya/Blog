[{"title":"建立浮起來的頁面","url":"/2022/06/03/建立浮起來的頁面/","content":"### 示意圖\n<img width=\"825\" alt=\"螢幕擷取畫面 2022-06-03 204528\" src=\"https://user-images.githubusercontent.com/67775387/171856500-be717474-8b0d-4779-a60f-bf2dda5f4f86.png\">\n\n這幾天在做 side project 的時候，發現自己沒有做過這種浮空的頁面，紀錄一下自己是怎麼做的。\n\n---------------------\n### 流程\n\n1. 為了讓浮空頁面背後的背景變暗，我自己用的方法是用一個半透明 `div` 蓋在畫面上，讓整個畫面變暗\n\n```css\n.darker {\n  position: fixed; /* 讓 div 固定在畫面的 top:0, left: 0 */\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  background: rgba(0, 0, 0, 0.75);\n  z-index: 10;\n}\n```\n2. 同樣用 `position: fixed`，建立一個能夠保持在畫面中間的頁面，這樣基本上就完成了。\n\n```css\n.page {\n  position: fixed;\n  width: 80%;\n  max-height: 90vh;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 999;\n}\n```\n"},{"title":"Use webpack to create react app with Typescript","url":"/2022/04/13/create-React-app-with-Typescript/","content":"1. 下載 React 17: \n```\nnpm install react@17 react-dom@17\n```\n2. 下載 typescript 及相關套件: \n```\nnpm install -D typescript @types/react @types/react-dom\n```\n3. 建立 `tsconfig.json`\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist/\",\n    \"noImplicitAny\": true,\n    \"module\": \"es6\",\n    \"target\": \"es5\",\n    \"jsx\": \"react-jsx\",\n    \"allowJs\": true,\n    \"strict\": true,\n    \"moduleResolution\": \"node\",\n    \"sourceMap\": true,\n    \"allowSyntheticDefaultImports\": true\n  },\n  \"include\": [\"./src/**/*\"]\n}\n```\n4. 建立 src folder，並在裡面建立 `env.d.ts`\n\n> 不能命名為 `index.d.ts`，[參考連結](https://stackoverflow.com/questions/52759220/importing-images-in-typescript-react-cannot-find-module)\n\n```js\n// 讓 typescript 能夠將結尾是 png | jpg 的檔案視為 module\ndeclare module \"*.png\";\ndeclare module \"*.jpg\";\n```\n5. 下載 webpack: \n```\nnpm install -D webpack webpack-cli webpack-dev-server\n```\n6. 下載 webpack 相關套件: \n```\nnpm install -D style-loader css-loader html-webpack-plugin mini-css-extract-plugin\n```\n7. 下載 babel 相關套件: \n```\nnpm install -D babel-loader @babel/core @babel/preset-typescript @babel/preset-env @babel/preset-react @babel/plugin-transform-runtime\n```\n8. 建立 `.babelrc`\n```json\n{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\", \"@babel/preset-typescript\"],\n  \"plugins\": [\"@babel/plugin-transform-runtime\"]\n}\n```\n9. 建立 `webpack.config.js`\n```js\nconst prod = process.env.NODE_ENV === \"production\";\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\n\nconst path = require(\"path\");\n\nmodule.exports = {\n  mode: prod ? \"production\" : \"development\",\n  entry: \"./src/index.tsx\",\n  output: {\n    path: path.resolve(__dirname, \"dist\"),\n    filename: \"index.[hash].js\",\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(jpe?g|png|svg)$/,\n        type: \"asset/resource\",\n      },\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, \"css-loader\"],\n      },\n      {\n        test: /\\.(ts|tsx)$/,\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: \"babel-loader\",\n        },\n      },\n    ],\n  },\n  devtool: \"inline-source-map\",\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: \"./src/index.html\",\n    }),\n    new MiniCssExtractPlugin({\n      filename: \"index.[hash].css\",\n    }),\n  ],\n  resolve: {\n    extensions: [\".tsx\", \".ts\", \".jsx\", \".js\"],\n  },\n};\n```\n10 `package.json`\n```json\n\"scripts\": {\n  \"start\": \"webpack serve\",\n  \"build\": \"set NODE_ENV=production&&webpack\"\n},\n```\n11. 加入 coding style 套件\n```\nnpm install -D eslint prettier eslint-config-prettier\n```\n12. `npx eslint --init`\n13. 在 `.eslintrc.js` 的 extends 內加入 prettier\n```js\nmodule.exports = {\n  extends: [\"prettier\"],\n  // 避免 import React 時錯誤\n  rules: {\n    \"no-use-before-define\": \"off\",\n    \"@typescript-eslint/no-use-before-define\": [\"error\"],\n  },\n};\n```"},{"title":"eslint prettier 配置","url":"/2022/04/11/eslint-prettier-配置/","content":"\n1. `npm install -D eslint prettier eslint-config-prettier`\n2. 在 `package.json` 裡增加 eslint --init\n```json\n\"scripts\": {\n  \"eslint--init\": \"eslint --init\",\n},\n```\n3. `npm run eslint--init`\n4. 在 `.eslintrc.js` 增加:\n```js\n  extends: [\n    \"prettier\"\n  ],\n```"},{"title":"React with Typescript Course","url":"/2022/04/05/React-with-Typescript-Course/","content":"\nBruce Typescript + React 課程筆記\n\n## Content\n- [Setup](#Setup)\n- [Create Functional Component with TS](#Create-Functional-Component-with-TS)\n- [React 網站 render 過程](#React-網站-render-過程)\n- [Styled-Component with Typescript](#Styled-Component-with-Typescript)\n- [自己建立Hook](#自己建立-Hook)\n- [使用 UseEffect 結合 API Request](#使用-UseEffect-結合-API-Request)\n- [將處理 API 相關的程序自定義成一個 Hook](#將處理-API-相關的程序自定義成一個-Hook)\n- [useRef](#useRef)\n- [useContext](#useContext)\n- [useMemo, useCallback](#useMemo-useCallback)\n- [useRoutes](#useRoutes)\n- [redux 介紹](#redux-介紹)\n\n## Setup\n1. `npx create-react-app my-app --template typescript`\n2. `npm install --save-dev eslint prettier prettier-eslint`\n3. add eslint init scripts to `package.json`\n```json\n{\n  \"scripts\": {\n    // eslint --init\n    \"eslint--init\": \"eslint --init\"\n  },\n}\n```\n4. `npm run eslint--init`\n\n> npm run eject 可以在我們 create-react-app 後顯示出被隱藏的 webpack 等設定檔\n\n## Create Functional Component with TS\n\nFunctional Component 在 Typescript 裡面的 type 為 `React.FunctionComponent`，也可以簡化成 `React.FC`。\n```jsx\nimport React from 'react'\n\nconst App: React.FunctionComponent = () => {\n  return <h1>Hello World!</h1>\n}\n\nexport default App\n```\n\n--------------------\n\n## Concepts & Tips\n+ 放在 `public` folder 底下的資源都會預設放在根目錄底下形成一個靜態資源\n+ `<React.Fragment/>` 可以直接用 `<>` `</>` 來替代\n\n--------------------\n\n## React 網站 render 過程\n0. 在我們將程式上架到 Server 的時候，Server 會將我們寫的 typescript 構建 (build) 成 `index.html`, `main.js` 以及 `main.css` ...。\n1. Client 在瀏覽器上對 server 發出請求 (Http request)\n2. 根據 client 送出的請求找到對應的路由 (`/` or `/about` or `/works` ...) ，server 根據路由回傳對應的 `index.html`, `main.js`, `main.css` ...\n3. 瀏覽器接收到 server 傳來的 response，解析 html (空白的 html) 並處理 js (包含 react 的內容)，然後開始執行 `ReactDom.render()`\n4. `ReactDom.render()` 將 html 渲染到 `<div id=\"root\">`\n\n--------------------\n\n## Styled-Component with Typescript\n\n### Setup:\n1. `npm install --save styled-components`\n2. `npm install --save @types/styled-components` (如果要用 Typescript)\n3. Create styled-component \n> 可以在 vscode 下載 [vscode-styled-components](https://marketplace.visualstudio.com/items?itemName=styled-components.vscode-styled-components) 讓我們能在他定義寫法下有 highlight\n\n```js\nimport React from 'react'\nimport './App.css'\nimport styled from 'styled-components'\n\n// 定義 styled-component 的 props\ntype ButtonProps = {\n  colorStatus: boolean\n}\n\n// 建立 styled-component\nconst Button = styled.button<ButtonProps>`\n  background: transparent;\n  border-radius: 3px;\n  border: 2px solid palevioletred;\n  color: ${(props) => (props.colorStatus === false ? 'black' : 'red')};\n  margin: 0 1em;\n  padding: 0.25em 1em;\n`\n\nconst App: React.FC = () => {\n  return (\n    <>\n      <Button colorStatus={false}>Click</Button>\n    </>\n  )\n}\n\nexport default App\n```\n\n----------\n## 自己建立 Hook\n[React docs](https://zh-hant.reactjs.org/docs/hooks-custom.html)\n\n要用 `use` 開頭來命名 hook，不然就無法起到 hook 的檢查機制。\n\n課堂中示範自己建立一個 HOC (High Order Function) 的 Hook:\n```js\nimport React, { useState } from 'react'\n\n// 定義如何計算出 score\nfunction getCurrentSocre () {\n  return 100\n}\n\nfunction getScoreByBoardName (boardName: string) {\n  if (boardName === 'boardA') return 200\n  else if (boardName === 'boardB') return 1000\n  return 0\n}\n\n// 自定義 HOC hook (High Order Function)\nfunction useScore (boardName: string) {\n  const [socre, setScore] = useState(\n    getCurrentSocre() + getScoreByBoardName(boardName)\n  )\n  // 回傳 score 以及 setScore 並定義他們的 type\n  return [socre, setScore] as [\n    number,\n    React.Dispatch<React.SetStateAction<number>>\n  ]\n}\n\nconst ScoreBoardA: React.FC = () => {\n  const [score, setScore] = useScore('boardA')\n  // 使用回傳回來的 setSocre 對 score 進行更新\n  const handlePlus = () => {\n    setScore(score + 10)\n  }\n  return (\n    <>\n      <p>Total Score: {score}</p>\n      <button onClick={handlePlus}>Plus</button>\n    </>\n  )\n}\n\nconst ScoreBoardB: React.FC = () => {\n  // eslint-disable-next-line\n  const [score, setScore] = useScore('boardB')\n  return <p>Total Score: {score}</p>\n}\n```\n-------\n## 使用 UseEffect 結合 API Request\n> 範例中使用 json placeholder 來模擬與後端 fetch 資料的情形\n\n使用 `useEffect`，在 ComponentDidMount 的時候獲取 data:\n```js\n// 定義 API request 回傳的資料型態\ntype Comment = {\n  postId: number\n  id: number\n  name: string\n  email: string\n  body: string\n}\n\nconst App: React.FC = () => {\n    // 在接收到 data 的時候定義接收到的資料型態\n  useEffect(() => {\n    fetch('https://jsonplaceholder.typicode.com/comments?postId=1')\n      .then((res) => res.json())\n      .then((data: Comment[]) => console.log(data))\n  }, [])\n}\n```\n將 `fetch` 拿到 `useEffect` 外，自己寫一個 async function 並透過斷言 (assertion) 來去指定型態\n```js\ntype Comment = {\n  postId: number\n  id: number\n  name: string\n  email: string\n  body: string\n}\n\nconst App: React.FC = () => {\n  // 定義 async function \n  async function fetchData () {\n    const res = await fetch(\n      'https://jsonplaceholder.typicode.com/comments?postId=1'\n    )\n    // Use assertion to define type of data\n    const data = (await res.json()) as Comment\n    return data\n  }\n\n  useEffect(() => {\n    fetchData()\n  }, [])\n}\n```\n\n使用 `useEffect` 結合更換 id (頁數) 獲得不同 data、控制錯誤處理以及 loading status:\n```js\ntype Comment = {\n  postId: number\n  id: number\n  name: string\n  email: string\n  body: string\n}\n\nconst App: React.FC = () => {\n  const [postId, setPostId] = useState(1)\n  // 設定 error types 為 null 或是 Error\n  const [error, setError] = useState<Error | null>(null)\n  const [loading, setLoading] = useState(false)\n\n  // 定義 async function 獲得 data \n  async function fetchData (id: number) {\n    // 開始 fetch 時，設 loading 為 true\n    setLoading(true)\n    try {\n      const res = await fetch(\n        `https://jsonplaceholder.typicode.com/comments?postId=${id}`\n      )\n      const data = (await res.json()) as Comment\n      console.log(id, data)\n    } catch (error) {\n      setError(error as Error)\n    }\n    // 結束時設為 false\n    setLoading(false)\n  }\n\n  // 當 postId 變動的時候，useEffect 會觸發並 fetchData\n  useEffect(() => {\n    fetchData(postId)\n  }, [postId])\n  )\n}\n```\n\n-------------\n\n## 將處理 API 相關的程序自定義成一個 Hook\n將與 API 相關的程序從原本的 Component 提取出來，可以讓 Component 更能夠專注在他的工作上面。\n\n完整程式碼:\n```js\nimport React, { useState, useEffect } from 'react'\n\n// 定義從 API Request 回傳回來的 data type\ntype Comment = {\n  postId: number\n  id: number\n  name: string\n  email: string\n  body: string\n}\n\n// 自定義一個 Hook\nfunction useFetchApi () {\n  // postId:   要抓 API 裡面的哪一塊資料 (page)\n  // error:    當 error 發生時會從原本的 null 變成 type of Error\n  // loading:  處理 loading status\n  // data:     從 api request 獲得的 data\n\n  const [postId, setPostId] = useState(1)\n  const [error, setError] = useState<Error | null>(null)\n  const [loading, setLoading] = useState(false)\n  const [data, setData] = useState<Comment[]>([])\n\n  async function fetchData (id: number) {\n    setLoading(true)\n    try {\n      const res = await fetch(\n        `https://jsonplaceholder.typicode.com/comments?postId=${id}`\n      )\n      const resData = (await res.json()) as Comment[]\n      setData(resData)\n    } catch (error) {\n      setError(error as Error)\n    }\n    setLoading(false)\n  }\n\n  // 當 postId 發生變動時，重新 fetchData\n  useEffect(() => {\n    fetchData(postId)\n  }, [postId])\n\n  return [data, loading, error, setPostId] as const\n}\n\nconst App: React.FC = () => {\n  // data, loading, error 因為都是 state，會隨著我們呼叫 setPostId 而改變\n  const [data, loading, error, setPostId] = useFetchApi()\n\n  function handleClick (id: number) {\n    setPostId(id)\n  }\n\n  return (\n    <>\n      <h1>Fetch API</h1>\n      <button onClick={() => handleClick(1)}>Id 1 data</button>\n      <button onClick={() => handleClick(2)}>Id 2 data</button>\n\n      {error === null\n        ? (\n        <p style={{ color: 'green' }}>資料獲取成功</p>\n          )\n        : (\n        <p style={{ color: 'red' }}>資料獲取失敗</p>\n          )}\n      {loading ? <p>loading...</p> : null}\n      <p>結果:</p>\n      {data.length > 0 && data.map((item) => <p key={item.id}>{item.email}</p>)}\n    </>\n  )\n}\n\nexport default App\n\n```\n\n----------\n## useRef\n\n`useRef` 與 `useState` 的其中一個差別在: `useRef` 在更新其值的時候不會觸發畫面的重新渲染，而 `useState` 在更新其值得時候會使畫面重新渲染。\n\n> React會確保 useRef 回傳出來的這個物件不會因為 React 元件更新而被重新創造。所以當我們的 component re-render 時，ref.current 的值不會被改變\n\n```js\nconst App: React.FC = () => {\n  const [hidden, setHidden] = useState(true)\n  const sumRef = useRef(0)\n\n  function click () {\n    sumRef.current = sumRef.current + 1\n    if (sumRef.current >= 5) {\n      setHidden(false)\n    }\n  }\n\n  return (\n    <>\n      <h1>Ref</h1>\n      <button onClick={click}>+1</button>\n      {!hidden && <div>被隱藏的區塊</div>}\n    </>\n  )\n}\n```\n\n使用 `useRef` 來達成 `document.querySelector` 的效果:\n\n```js\nconst App: React.FC = () => {\n  const h1Ref = useRef<HTMLHeadingElement>(null)\n\n  useEffect(() => {\n    // 相較於使用: const h1 = document.querySelector('h1')\n    const h1 = h1Ref.current\n    console.log(h1) // log: <h1>My page title</h1>\n  }, [])\n\n  return <h1 ref={h1Ref}>My page title</h1>\n}\n```\n## useContext\n能夠有效幫助我們減少上層 Component 傳遞給下層 Component 的參數。\n```js\nimport React, { createContext, useState, useContext } from 'react'\n\n// 定義初始值\nconst defaultValue = {\n  btnVisible: false\n}\n\n// 建立 Context\nconst BtnContext = createContext(defaultValue)\n\n// 建立 Provider ( 需要包裹住 Consumer )\nexport const BtnProvider: React.FC = ({ children }) => {\n  const [btnVisible, setBtnVisible] = useState(false)\n\n  return (\n    <BtnContext.Provider value={{ btnVisible }}>{children}</BtnContext.Provider>\n  )\n}\n\n// 建立 Consumer\nexport const useBtnContext = () => {\n  return useContext(BtnContext)\n}\n```\n\n## useMemo, useCallback\n在 javascript 中比較一個 object 是否相同時，如果我們宣告兩個內容一樣的 object，進行 `===` 比較，會發現他們比較結果是 `false`\n```js\nconst obj1 = {}\nconst obj2 = {}\nconsole.log(obj1 === obj2) // false\n```\n如果我們在 React Component 內宣告 function 或是 object 的話，在 React 每次 re-render 的時候都會重新建立一個新的 object / function。所以這時如果我們要判斷 object 是否改變的話，判斷結果就一定會是有改變的。所以這時就能使用 `useMemo` 以及 `useCallback` 來幫我們解決這個問題。\n\n> `useMemo` 主要用來處理 Object，`useCallback` 用來處理 function\n\n```js\nconst App: React.FC = () => {\n  const [value, setValue] = useState(false)\n\n  // common object\n  const obj = { name: 'alee' }\n  \n  // common function\n  function fun () {\n    console.log('yo')\n  }\n\n  // wrap into useMemo, useCallback\n  const memoObj = useMemo(() => obj, [])\n  const memoFunc = useCallback(fun, [])\n\n  // this will execute when re-render\n  useEffect(() => {\n    console.log('obj in effect')\n  }, [obj])\n\n  // this won't execute when re-render\n  useEffect(() => {\n    console.log('memoObj in effect')\n  }, [memoObj])\n\n  // this will execute when re-render\n  useEffect(() => {\n    console.log('fun in effect')\n  }, [fun])\n\n  // this won't execute when re-render\n  useEffect(() => {\n    console.log('memoFunc in effect')\n  }, [memoFunc])\n\n  return (\n    <>\n      <h1>Testing</h1>\n      <button onClick={() => setValue(!value)}>Click me to re-render</button>\n    </>\n  )\n}\n```\n\n## useRoutes\n`useRoutes` 是由 react-router-dom 所提供的一個 Hook，可以幫助我們建立 router config。底下範例介紹如何使用 react-router-dom 所提供的 `useRoutes`, `Outlet`, `RouteObject`, `useParams`, `Link`。\n\n### 建立各個 Page 的 Component:  \nOutlet 指定子 Component 出現在父 Component 的位置，這邊範例中的子 Component 是 <Item/>\n```js\nimport {\n  Outlet,\n  useParams,\n  Link\n} from 'react-router-dom'\n\nconst Home: React.FC = () => {\n  return <h1>Home</h1>\n}\n\nconst About: React.FC = () => {\n  return (\n    <h1>\n      About <Link to=\"/about/1\">Go to id 1</Link>\n      {/* Outlet 指定子 Component 出現在父 Component 的位置，這邊範例中的子 Component 是 <Item/> */}\n      <Outlet />\n    </h1>\n  )\n}\n\nconst Item: React.FC = () => {\n  const { id } = useParams()\n  return <p>Item: {id} in about page</p>\n}\n\nconst Nomatch: React.FC = () => {\n  return <h1>No match</h1>\n}\n```\n\n### 建立 router config:  \n( useRoutes 會接收 RouteObject[] 的型態，所以我們從 react-router-dom 匯入 RouteObject )\n```js\nimport type {\n  RouteObject,\n} from 'react-router-dom'\n\n// useRoutes 會接收 RouteObject[] 的型態，所以我們從 react-router-dom 匯入 RouteObject\nconst routerConfig: RouteObject[] = [\n  {\n    path: '/',\n    element: <Home />\n  },\n  {\n    path: '/about',\n    element: <About />,\n    children: [{ path: ':id', element: <Item /> }]\n  },\n  {\n    path: '*',\n    element: <Nomatch />\n  }\n]\n```\n### 將 routerConfig 擺入 App\n將剛剛建立的 routerConfig 傳入 useRoutes，並將回傳結果擺入 App\n```js\nimport {\n  useRoutes\n} from 'react-router-dom'\n\nconst App: React.FC = () => {\n  // 將剛剛建立的 routerConfig 傳入 useRoutes，並將回傳結果擺入 App\n  const route = useRoutes(routerConfig)\n  return <>{route}</>\n}\n```\n\n## 新專案要建立 Router 的步驟\n1. 建立好 `pages` folder ( 擺之後的各個 page components )\n2. 寫好 router config ( 在 `src` 資料夾內建立 `routes.tsx` )\n3. 引入 `BrowserRouter`\n4. 在 `App.tsx` 裡面使用 `useRoutes` 初始化路由\n\n## redux 介紹\n- action: 是什麼動作，帶了什麼資料\n```js\n{\n  type: 'deposit' // 什麼動作\n  payload: 10 // 附帶的資料\n}\n```\n- reducer: switch case 的 function，負責處理 action 的邏輯\n- dispatch: 派發給 action 給 reducer\n- store: 包含 state 以及 reducer，並在更新 state 後會通知 UI 重新渲染"},{"title":"CSR vs SSR","url":"/2022/04/05/CSR-vs-SSR/","content":"## CSR (Client-Side Render)\n> CSR 的問題在於 SEO 不佳以及造訪網頁的第一個畫面會有較長空白等待時間\n\n用戶從 server 拿到的 `index.html` 其內容是空白的 (還沒渲染)，必須要透過執行 Javascript 將網頁內容渲染到 HTML 上面。如果附帶的 Javascript 還沒執行完，用戶就只能看到空白的頁面 (對使用者體驗以及 SEO 會有負面效果)。\n\n優點:\n+ 降低伺服器的運算以及流量的負荷量\n+ 透過 Javascript 更新整體頁面，routing 時畫面不需要一片白之後再重新渲染\n\n## SSR (Server-Side Render)\n用戶從 server 那邊接收到 `index.html` 之前，HTML 就已經被渲染出來了 (pre-render)。所以使用者比起等待空白頁面，會覺得網站的響應速度會比 SPA 還要快。\n\n缺點: \n+ 伺服器一次需要計算完畫面再將整頁送出，這樣對於伺服器的運算及流量的負荷都比較大\n+ Routing 時因為要重新跟 Server 要新的頁面，所以會閃白更新\n\n## Isomorphic JavaScript\n將上面兩個方式結合，第一個顯示的畫面由伺服器端計算處理 (SSR)，剩下的畫面由 Javascript 處理 (CSR)。\n\n像是 [Next.js](https://nextjs.org/) 就能處理 SSR。\n\n\n------------------------------\nRef: \n+ [前端三十｜18. [FE] 為什麼網站要做成 SPA？SSR 的優點是什麼？](https://medium.com/schaoss-blog/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%8D%81-18-fe-%E7%82%BA%E4%BB%80%E9%BA%BC%E7%B6%B2%E7%AB%99%E8%A6%81%E5%81%9A%E6%88%90-spa-ssr-%E7%9A%84%E5%84%AA%E9%BB%9E%E6%98%AF%E4%BB%80%E9%BA%BC-c926145078a4)\n+ [初探 Server-Side-Rendering 與 Next.js](https://medium.com/starbugs/%E5%88%9D%E6%8E%A2-server-side-rendering-%E8%88%87-next-js-%E6%8E%A8%E5%9D%91%E8%A8%88%E7%95%AB-d7a9fb48a964)"},{"title":"Style your windows powershell and git bash","url":"/2022/04/02/Style-your-windows-powershell-and-git-bash/","content":"\n之前一直看到別人將自己的 terminal 改的很酷炫，可以顯示 git branch 而且還有一大堆顏色，今天有時間研究了一下終於也把自己的 terminal 增加了這些功能，順便記錄一下操作過程以免之後換電腦不知道要怎麼用。\n\n完成後的模樣:\n\n<img width=\"725\" alt=\"螢幕擷取畫面 2022-04-03 145841\" src=\"https://user-images.githubusercontent.com/67775387/161415750-1b5e7d01-2391-4450-a482-57a00830f66f.png\">  \n\n## Windows PowerShell\n基本上如果是要在 windows powershell 上有這些功能，只要跟著官方提供的方式 ([教學課程：使用喔 My Posh 設定 PowerShell 或 WSL 的自訂提示](https://docs.microsoft.com/zh-tw/windows/terminal/tutorials/custom-prompt-setup#customize-your-powershell-prompt-with-oh-my-posh) 就可以完成了，大致步驟如下:\n\n1. 從 [NerdFonts](https://www.nerdfonts.com/font-downloads) 安裝想要的字形 (為了避免有些 icon 跑不出來出現白框框)，解壓縮後應該會有 `True Type font file` 的檔案，將這些檔案丟到 *控制台* -> *外觀及個人化* -> *字形* 裡面\n2. 從 windows terminal 的設定中，點擊 *powershell* -> *外觀*，將文字改成下載的字體\n3. 在 terminal 上輸入\n```powershell\nInstall-Module oh-my-posh -Scope CurrentUser\n```\n下載 oh-my-posh 以及其主題\n4. 從 [oh-my-posh themes](https://ohmyposh.dev/docs/themes) 上挑自己想要的主題\n5. 在 terminal 上輸入\n```powershell\ncode $PROFILE\n```\n開啟 vscode 設定我們的 PowerShell 設定檔\n6. 在開啟的檔案中新增程式碼:\n```powerShell\nImport-Module oh-my-posh\nSet-PoshPrompt -Theme paradox\n```\nparadox 是主題的名稱，也可以換成其它自己想要的主題\n\n> PowerShell 設定檔是在 PowerShell 啟動時執行的指令碼。您可以使用設定檔做為登入腳本來自訂環境。\n \n接下來重新開啟 terminal 就可以有新的主題了!\n\n### Git bash\n我自己是在 windows terminal 上使用 git bash，方法可以參考 [如何在 window terminal 增加 git bash](https://aleetsaiya.github.io/2022/01/20/window-terminal-%E5%A2%9E%E5%8A%A0-git-bash/)。\n\n1. 跟上述第一步一樣安裝字體\n2. 從 windows terminal 的設定中，點擊 *git bash* -> *外觀*，將文字改成下載的字體\n3. 在 `C:\\Program Files\\Git\\usr\\bin` 內，擺入 `oh-my-posh.exe`\n4. 在 git bash 上輸入 `$HOME`\n5. 在顯示的資料夾位置裡面加入自己想要的主題檔，像是我想要的主題叫做 *paradox*，就可以從 [oh-my-posh themes](https://github.com/JanDeDobbeleer/oh-my-posh/tree/main/themes) 裡面找到名叫 [paradox.omp.json](https://github.com/JanDeDobbeleer/oh-my-posh/blob/main/themes/paradox.omp.json) 的 json 檔。\n6.在 `$HOME` 顯示的資料夾位置內建立 `.bashrc` 檔。\n7. 在 `.bashrc` 內輸入\n```powershell\neval \"$(oh-my-posh init bash --config ~/paradox.omp.json)\"\n```\n> `paradox` 是主題的名稱，也可以換成其它自己想要的主題 \n\n接下來重新開啟 terminal 新的主題就會開始套用了喔!"},{"title":"Webpack start","url":"/2022/03/31/Webpack-start/","content":"[布魯斯前端 Webpack 快速入門](https://www.youtube.com/watch?v=uP6KTupfyIw) 筆記\n\n> Webpack 能夠幫我們將多種不同的檔案打包\n\n## Basic Setup\n1. `npm install webpack --save-dev`\n2. 建立 `webpack.config.js`\n```js\n// 調用 path module in node.js\nconst path = require(\"path\");\n\nmodule.exports = {\n  entry: \"./src/index.js\",\n  output: {\n    // path.resolve 能夠從左到右將相對路徑轉成絕對路徑\n    // __dirname 為當前資料夾位置\n    path: path.resolve(__dirname, \"dist\"),\n    filename: \"main.bundle.js\",\n  },\n  // mode 可以為 development | production  \n  mode: \"development\",\n};\n```\n3. 在 `package.json` 內增加 scripts 用來讓 webpack compile 檔案\n```json\n\"scripts\": {\n  // compile\n  \"build\": \"webpack\",\n  \"watch\": \"webpack --watch\",\n},\n``` \n\nMore about `module`: [visit](https://ithelp.ithome.com.tw/articles/10185008)\n\n-------------------------\n\n## Dev Server\n如果要建立一個 local server 的話，webpack 有提供方法來幫助我們建立\n\n1. 在 `webpack.config.js` 內加入: \n```js\nmodule.exports {\n  // ...\n  // ...\n  devServer: {\n    // 設定 static html location\n    static: {\n      directory: path.join(__dirname, \"dist\"),\n    },\n    compress: false,\n    port: 9000,\n  },\n}\n```\n\n2. 在 `package.json` 中加入 script\n```json\n\"scripts\": {\n  // create a local server   \n  \"dev\": \"webpack serve\"\n}\n```\n-------------------------\n\n## source-map\n讓我們能夠從 console 中找到 bundle 前程式碼的位置。\n\n在 `webpack.config.js` 中設置:\n```js\nmodule.exports = {\n  // 讓我們能夠從 console 中找到 bundle 前程式碼的位置\n  devtool: \"source-map\"\n}\n```\n\n-------------------------\n\n## Loader\n> Loader 有點像是轉換器，他會根據 `test` 上的正則表示法來掃描檔案名稱，然後再將不是 Javascript 的檔案，或是新的 Javascript 語法轉換成瀏覽器看得懂的 JS code。\n\n### CSS Loader\n在沒有加入 CSS Loader 的情況下，Webpack 預設只能讀的懂 Javascript，所以在我們 `import` css 檔案後程式會報錯。這時就要加入 CSS Loader\n\nDocs: [Webpack css-loader](https://webpack.js.org/loaders/css-loader/#root)\n\n1. `npm install --save-dev css-loader style-loader`\n2. 在 `webpack.config.js` 內加入:\n```js\nmodule.exports {\n  // ...\n  // ...\n  module: {\n    rules: [\n      {\n        // 用正則表達式跟 webpack 說看到的所有 css 檔案都要用底下的 loaders 解析\n        test: /\\.css$/i,\n        use: [\"style-loader\", \"css-loader\"],\n      },\n    ],\n  },\n}\n```\n\n### Babel Loader\n在 webpack 中添加 babel，使瀏覽器能夠支援新的 Javascript 語法\n\ndocs: [Babel setup](https://babeljs.io/setup#installation)\n\n1. `npm install --save-dev babel-loader @babel/core`\n2. 在 `webpackage.config.js` 內加入:\n```js\nmodule.exports = {\n  rules: [\n    {\n      test: /\\.m?js$/,\n      exclude: /node_modules/,\n      use: {\n        loader: \"babel-loader\",\n      }\n    }\n  ]\n}\n```\n3. `npm install @babel/preset-env --save-dev`\n4. 建立 `babel.config.json`\n```json\n{\n  \"presets\": [\"@babel/preset-env\"]\n}\n```\n\n> 需要使用到 async await 時\n\n+ `npm install -D @babel/plugin-transform-runtime`\n+ 在 `.babelrc.js` 裡面增加:\n```js\nmodule.exports = {\n  plugins: [\"@babel/plugin-transform-runtime\"],\n};\n```\n\nRef: [https://blog.51cto.com/u_15252994/2853975](https://blog.51cto.com/u_15252994/2853975)\n\n\n### Asset Modules\nAsset Module 能夠使我們不用特別設定所有的 asset files' loader，就能夠使用多種檔案類型。像是我會使用到 gif 檔的話就可以在 `test` 中設定 `.gif`。\n\ndocs: [Webpack Asset Module](https://webpack.js.org/guides/asset-modules/#resource-assets)\n\n在 `webpackage.config.js` 內加入:\n```js\nmodule.exports = {\n  rules: [\n     {\n       test: /\\.gif/,\n       type: 'asset/resource'\n     }\n   ]\n },\n}\n```\n-------------------------\n\n## Plugin\n> Plugin serve the purpose of doing anything else that a loader cannot do.\n\n### html-webpack-plugin\n如果要避免 cache ，希望每次 bundle 出來的 js 檔都要有不一樣的名字，可以使用這個 plugin。它能夠幫我們自動生成 html 檔，以及透過設定 `[hash]` 將 js 檔的名稱增加亂數並自動在 html head 中嵌入\n\n1. `npm install --save-dev html-webpack-plugin`\n2. 在 `webpackage.config.js` 內加入:\n```js\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports {\n  plugins: [\n    output: {\n      path: path.resolve(__dirname, \"dist\"),\n      // 增加 [hash] 讓我們執行 npm run build 的時候會產生新的亂數檔\n      filename: \"main.[hash].bundle.js\",\n    },    \n    new HtmlWebpackPlugin({\n      // 這邊加入 template 是為了讓產生出來的 dist/index.html 會依照 src/index.html 的內容樣本來產生，不然不會有內容\n      template: \"./src/index.html\",\n    }),\n  ],\n}\n```\n> 如果 html 有使用到 images 等的 resource，可以下載 html-loader\n\n1. `npm install --save-dev html-loader`\n2. webpack.config.js:\n```js\nmodule: {\n    rules: [\n      {\n         test: /\\.(html)$/,\n         use: ['html-loader']\n      }\n    ]\n},\nplugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html'\n    })\n  ]\n```\n\n### MiniCssExtractPlugin\n如果我們使用上述引入 css，會發現 css 都在 `<head/>` 裡面，因此可以使用這個 plugin 來幫助我們建立一個額外的 css 檔\n\n> Note that if you import CSS from your webpack entrypoint or import styles in the initial chunk, mini-css-extract-plugin will not load this CSS into the page. Please use html-webpack-plugin for automatic generation link tags or create index.html file with link tag.\n\ndocs: [Webpack MiniCssExtractPlugin](https://webpack.js.org/plugins/mini-css-extract-plugin/)\n\n1. `npm install --save-dev mini-css-extract-plugin`\n2. 在 `webpackage.config.js` 內加入:\n```js\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/i,\n        use: [MiniCssExtractPlugin.loader, \"css-loader\"],\n      },\n    ],\n  },\n  plugins: [new MiniCssExtractPlugin({\n    // 增加 [hash] 讓 bundle 出來的檔案有亂數，如果沒有要產生亂數的話不用傳入參數也可以\n    filename: \"main.[hash].css\",\n  })],\n}\n```"},{"title":"Typescript start","url":"/2022/03/31/Typescript-begin/","content":"\n[布魯斯的 TypeScript 入門攻略｜輕鬆打造實時聊天室](https://hiskio.com/courses/628/about) 課程筆記\n\n## Setup\n1. `npm install -g typescript`\n2. `tsc --init`\n3. setting `ts.config`\n```json\n{\n  // 我們寫的 index.ts 的資料夾\n  \"rootDir\": \"./src\"\n  // 設定輸出資料夾\n  \"outDir\": \"./dist\"\n  // 允許我們使用 js 檔\n  \"allowJS\": true\n  // 開啟這個選項能夠讓我們在 browser 的   console 中直接連結到是哪行 ts 檔輸出的，方便   debug\n  \"sourceMap\": true\n}\n```\n4. run `tsc` \n \n---------------------\n\n## Setup webpack with ts-loader\n\n因為 ts-loader 會使用 `tsc` 來幫我們處理 typescript 的檔案，所以要建立 `ts.config` 來設定 `tsc` 的一些參數。\n\ndocs: [Webpack Typescript](https://webpack.js.org/guides/typescript/)\n\n1. `npm install typescript ts-loader`\n2. 建立 `tsconfig.json`\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist/\",\n    \"noImplicitAny\": true,\n    \"module\": \"es6\",\n    \"target\": \"es5\",\n    \"jsx\": \"react\",\n    \"allowJs\": true,\n    \"moduleResolution\": \"node\",\n\n    // path mapping\n    // 讓我們可以使用其他符號代表路徑\n    \"baseUrl\": \"./src\",\n    \"paths\": {\n      // @/* 代表 @/ 底下的東西會對應到 [baseUrl]/* (./src/)\n      \"@/*\": [\"*\"]\n    }\n  }\n}\n```\n3. 設定 `webpack.config.js`\n```js\nconst path = require('path');\n\nmodule.exports = {\n  entry: './src/index.ts',\n  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: 'ts-loader',\n        exclude: /node_modules/,\n      },\n    ],\n  },\n  resolve: {\n    // webpack 默認只會編譯 js 檔，設定 resolve 讓 webpack 能夠將 tsx 以及 ts 也被 webpack 編譯\n    extensions: ['.tsx', '.ts', '.js'],\n    // 要使用 path mapping 的話，要加 alias 以免 webpack 看不懂\n    // 設定 @ 對應到 src\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n    }\n  },\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n};\n```\n\n> ts-loader uses tsc, the TypeScript compiler, and relies on your tsconfig.json configuration. Make sure to avoid setting module to \"CommonJS\", or webpack won't be able to **tree-shake** your code.\n\ntree-shaking 能夠讓我們在 import 例如 `axios/get` 的時候不會將 `axios` 全部 import 近來，只會 import `get`，能夠有效地增加網站效能。 \n\n---------------------\n\n## Typescript 語法\n### 斷言\n斷言就是我們在一個變數後面加上 `as`，然後這個變數的型態就會變成我們設定的型態。\n\n> 可以應用在當我們 fetch 一個 API 的時候。在 fetch 之前 Typescript 不會知道 fetch 完後的變數長什麼樣子，所以在 fetch 完後我們就可以自己用 `as` 來去設定它的型態\n\n```js\nasync function getData() {\n  const res = await fetch(\"https://jsonplaceholder.typicode.com/todos/1\")   \n  // fetch 完後設定資料型態\n  const data = (await res.json()) as {\n    userId: number;\n    id: number;\n    title: string;\n    completed: boolean;\n  };\n  return data\n}\n```\n### 強制斷言\n有時候可能我們知道這個變數型態已經從原本的變成另一個型態，但是 Typescript 不給我們直接轉，像是底下的情況:\n```js\nlet liveName2 = 91;\nlet liveName3 = liveName2 as string; //error -> Conversion of type 'number' to type 'string' may be a mistake\n```\n這時候就能使用強制斷言，先將變數型態轉成 `unknown`，再轉換成其它型態\n```js\nlet liveName2 = 91;\nlet liveName3 = liveName2 as unknown as string;\n```\n\n### Never\nnever 就是 Typescript 判斷永遠不可能發生的類型，像是底下例子:\n```js\nlet liveName: string | number;\nliveName = \"alee\";\nliveName = 9;\n\n// never -> typeof liveName 不可能是 string\nif (typeof liveName === \"string\") {\n   liveName.split(\"\"); //error \n}\n```\n\n### Type, Interface 擴充\n使用 `type` 的話用 `&` 可以進行擴充，使用 `interface` 的話用 `extends` 可以進行擴充。\n```js\n// type\ntype Animal = {\n  name: string;\n};\n\ntype Dog = Animal & {\n  age: number;\n};\n\n// interface\ninterface Animal2 {\n  name: string;\n}\n\ninterface Dog2 extends Animal {\n  age: number;\n}\n```\n\n> Type 與 Interface 差別在重複命名 Interface 的話會將原有的 Interface 進行擴充，而 Type 則無法重複命名。\n\n### enum\n設定每個符號代表的東西讓程式碼更容易閱讀\n```js\nenum LiveStatus {\n  \"streaming\" = 0,\n  \"closed\" = 1,\n  \"multiple\" = 2,\n}\n\nlet liveStatus = 0;\nif (liveStatus === LiveStatus.streaming) {\n  // ...\n}\n\n```\n\n### Implement Interface\ninterface 可以用來約束建立出來的 class 必須需要有什麼功能以及屬性\n```js\n// 建立 interface\ninterface UserInterface {\n  id: number;\n  name: string;\n  age: number;\n  address: string;\n\n  // 會員功能\n  add: (data: any) => void;\n  update: (id: number) => boolean;\n  delete: (id: number) => boolean;\n}\n\n// implements interface\nclass LiveUser implements UserInterface {\n  // 必須要有 interface 定義的東西\n  id: number;\n  name: string;\n  age: number;\n  address: string;\n\n  add(data: any) {}\n  update(id: number) {\n    return true;\n  }\n  delete(id: number) {\n    return true;\n  }\n\n  // 也可以新增額外的功能\n  startLive() {}\n  endLive() {}\n}\n```\n\n### Abstract class\nAbstract class 本身可以有自己的功能，也可以約束 `extends` 的 class 需要有什麼功能\n\n```js\nabstract class Animal {\n  run() {\n    console.log(\"run ...\");\n  }\n  // 要求需要實作出 hello\n  abstract hello(): void;\n}\n\nclass Dog extends Animal {\n  // 實作 hello\n  hello() {\n    console.log(\"Hello\");\n  }\n}\n```\n\n### 泛型\n基礎泛型就是打 `<>` 然後將我們期望的 type 傳進去\n```js\nfunction hello<T, U>(text: T, text2: U): T {\n  console.log(text, text2);\n  return text;\n}\n\nhello<number, string>(123, \"alee\");\nhello<boolean, string>(true, \"alee\");\n```\n使用 interface 搭配泛型:\n```js\ninterface Card<T> {\n  title: string;\n  desc: T;\n}\n\nfunction printCardInfo<T>(desc: T): Card<T> {\n  const data: Card<T> = {\n    title: \"bruce\",\n    desc,\n  };\n  return data;\n}\n```\n為了確保泛型內擁有特定的 property，可以使用 `extends` 來幫我們確認傳入的泛型型態是擁有這個 property 的。\nex.\n```js\n// 確保要傳入的型態含有 length\nfunction logArrLen<T extends Array<number>>(arr: T) {\n  console.log(arr.length);\n}\n\nlogArrLen<Array<number>>([1, 2, 3]);\n```\n\n在泛型中使用 `infer` 的意思是: 我們先檢查條件有沒有達成，如果達成了的話就會透過 `infer` 幫我們建立一個參數，沒達成就不會透過 `infer` 建立參數，直接變成我們設定的 else 參數。\nex.\n```js\n// 檢查 T 是否有 extends Array，如果有的話建立參數 P (參數的值就是我們傳進去 Array 的值)\ntype Check<T> = T extends Array<infer P> ? P : never;\n\ntype Q = Check<[number]>; // type: number\ntype R = Check<[\"alee\", 123]>; //type: 'alee', 123\ntype G = Check<string>; // type: never\n```\n\n### keyof\n使用 `keyof` 可以獲得一個 type 的 keys 的 union。\nex.\n```js\n// keyof\ninterface UserCard {\n  name: string;\n  age: number;\n  cardTitle: string;\n  cardDesc: string;\n}\n\n// type: name | age | cardTitle | cardDesc\ntype UserCardKeys = keyof UserCard;\n\nconst key1: UserCardKeys = \"name\";\nconst key2: UserCardKeys = \"cardTitle\";\nconst key3: UserCardKeys = \"cardDesc\";\n\n// 確保 K 是 T 的其中一個 key\nfunction getValue<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n```\n\n### Map\n```js\ntype UserData = {\n  id: string;\n  userName: string;\n  roomName: string\n}\n\nexport default class UserService {\n  private userMap: Map<string, UserData>\n\n  constructor() {\n    this.userMap = new Map()\n  }\n\n  addUser(data: UserData) {\n    this.userMap.set(data.id, data)\n  }\n}\n```\n\n## ES6 ES-Module vs CommonJS\n\n+ CommonJS: 早期在開發 Node.js 的時候 Javascript 還沒有支援模組化的概念。使用 `require` 以及 `module.exports`\n+ ES Module: ES6 新增的 Javascript 標準模組化方式。使用 `export` 以及 `import` \n\n```js\nimport \"./index.css\";\n\n// CommonJS -> Nodejs 開發\nconst data = require(\"./commonJS\");\n\n// ES6 ES Module -> js標準\nimport { age, userName } from \"./es6Module\";\nimport * as all from \"./es6Module\";\n```\n"},{"title":"How to use Markdown syntax in Google Docs","url":"/2022/03/31/How-to-use-Markdown-syntax-in-Google-Docs/","content":"Visit post: [Compose with Google Markdown in Google Docs on web](https://workspaceupdates.googleblog.com/2022/03/compose-with-markdown-in-google-docs-on.html)\n\nGoogle Workspace 在 2022.03.29 的時候釋出了新消息，表示能夠在 Google Docs 內透過勾選 **Automatically detect Markdown** 使我們能夠在 Google Docs 中使用 Markdown Syntax，身為 Markdown 的粉絲之一聽到這個消息真的是很令人高興!\n\n<img width=\"518\" alt=\"Google Docs\" src=\"https://user-images.githubusercontent.com/67775387/160954231-9ea42803-c3f6-4ae1-964c-96acd3ba03c8.png\">\n\n\n使用中文版的人可以在 [工具] > [偏好設定] 中找到 [自動偵測 Markdown]，將它勾起來之後我們就能在 Google Docs 中寫 Markdown syntax 了 !\n\n<img width=\"318\" alt=\"google-docs-setting\" src=\"https://user-images.githubusercontent.com/67775387/160954789-1d7ef857-c2e9-40e0-afc4-c1bad8722151.png\">\n"},{"title":"Next.js Getting Start Note","url":"/2022/03/28/Next-js-Getting-Start-Note/","content":"## 目錄\n\n1. [Pages](#pages)\n   + Dynamic Routes\n   + Link\n2. [Pre-render](#pre-render)\n   + Static generation\n   + Server side rendering\n   + getServerSideProps, getStaticProps 差別\n3. [Head](#head)\n4. [Image](#image)\n   + local image\n   + remote image\n   + LCP\n   + Priority\n\n\n## Pages\n在 `pages` folder 裡面的 React Component，會根據檔案名稱對應到 route，像是:\n\n```jsx\n// (網址) → 檔案位置 \n/ → pages/index.js\n/about → pages/about.js\n/blog/hello-world → pages/blog/[slug].js\n```\n(被中括號括住的檔名可以使用 dynamic routes，底下介紹)\n\n### Dynamic Routes\n可以將檔案/資料夾名稱設定成像是 `[pid]` 這種用中括號包起來的檔案名稱，它會自動對應網址參數名稱\n```js\n// 在 post資料夾裡面的 [pid]資料夾裡面的 [comment].js\n// post/[pid]/[comment].js\nimport { useRouter } from \"next/router\";\n\nconst Post = () => {\n  const router = useRouter();\n  // 從網址參數中提取 pid 以及 comment   \n  // 如果網址是 \"/post/1/hello\"，則 pid 為 1，comment 為 hello \n  const { pid, comment } = router.query;\n  \n  return (\n    <p>\n      Pid: {pid} Comment: {comment}\n    </p>\n  );\n};\n\nexport default Post;\n\n```\n### Link\n使用 `<Link/>` 來相連不同的 pages，像是底下建立一個 Home Pages 來連接各個其他的 pages\n\n```js\nimport Link from 'next/link'\n\nfunction Home() {\n  return (\n    <ul>\n      <li>\n        {/* pages/index.js */}\n        <Link href=\"/\">\n          <a>Home</a>\n        </Link>\n      </li>\n      <li>\n        <Link href=\"/about\">\n          <a>About Us</a>\n        </Link>\n      </li>\n      <li>\n        <Link href=\"/blog/hello-world\">\n          <a>Blog Post</a>\n        </Link>\n      </li>\n    </ul>\n  )\n}\n\nexport default Home\n```\n\n## Pre-render\nNext.js 會 pre-render 所有的 pages，而 pre-render 又可分為 `static generation` 以及 `server-side rendering`，為了更好的效能，官方推薦使用 `static generation`。\n詳細: [link](https://nextjs.org/docs/basic-features/pages#pre-rendering)\n\n### Static generation\n\n> If a page uses Static Generation, the page HTML is generated at build time. That means in production, the page HTML is generated when you run next build . This HTML will then be reused on each request. It can be cached by a CDN.\n\n使用 static generation 時, 若我們需要使用外部資源來引入我們的 component 的話，可以`export async getStatciProps` 來獲得外部資源。\n\n底下有一個 Blog Component 負責 render 外部引入的 posts\n```js\nfunction Blog({ posts }) {\n  return (\n    <ul>\n      {posts.map(post => <li>{post.title}</li>)}\n    </ul>\n  )\n}\n\nexport default Blog\n```\n\n而接下來我們要 `export` 一個 `async` function `getStaticProps` ，讓這個 Component 能在 pre-render 時就獲得外部資源 ( `getStaticProps` 會在 build time 時被呼叫)\n```js\n// This function gets called at build time\nexport async function getStaticProps() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n\n  // By returning { props: { posts } }, the Blog component\n  // will receive posts as a prop at build time\n  return {\n    props: {\n      posts\n    }\n  } \n}\n```\n\n### Server-side Rendering\n> If a page uses Server-side Rendering, the page HTML is generated on each request.\n\nserver-side rendering 需要使用到外部資源的話，我們可以 `export async getServerSideProps`，它會在每次送出 request 時被呼叫。\n\n```js\nfunction Pages({ data }) {\n  // Render data\n}\n\n// This gets called on every request\nexport async function getServerSideProps() {\n  // Fetch data from exnternal API\n  const res = await fetch('https://.../data')\n  const data = await res.json();\n\n  // Pass data to page via props\n  return { props: {data} }\n}\n```\n### getServerSideProps, getStaticProps 差別\n`getServerSideProps` 會在每次 request 的時候被呼叫，而 `getStaticProps` 只會在 build time 的時候被呼叫。\n\n## Head\n我們可以在 component 中引入 Next.js 提供的 `Head` 來設定 html 中的 `<head>`\n```js\nimport Head from \"next/head\";\n\nfunction HomePage() {\n  return (\n    <div>\n      <Head>\n        <title>Here is HomePage</title>\n        <meta name=\"viewport\" content=\"initial-scale=1.0 width=device-width\" />\n      </Head>\n      <p>Welcome to Next.js!</p>\n    </div>\n  );\n}\n\nexport default HomePage;\n\n```\n\n## Image\n從 Next.js 中匯入 `Image` component，並加入入圖片的 `src`。\n\n### Local Image\n> Next.js will automatically determine the width and height of your image based on the imported file\n```js\n// use local image \nimport profilePic from '../public/me.png'\nimport Image from 'next/image'\n\nfunction Home() {\n  return (\n    <>\n      <h1>My HomePage</h1>\n      <Image\n        src={profilePic}\n        alt='Picture of the author'\n        // width={500} automatically provided\n        // height={500} automatically provided\n        // blurDataURL=\"data:...\" automatically provided\n        // placeholder=\"blur\" // Optional blur-up while loading\n      />\n      <p>Welcome to my homePage!</p>\n    <>\n  )\n}\n```\n\n### Remote Image\n> To use a remote image, the src property should be a URL string, which can be relative or absolute. Because Next.js does not have access to remote files during the build process, you'll need to provide the width, height and optional blurDataURL props manually\n\nMore: [link](https://nextjs.org/docs/basic-features/image-optimization#remote-images)\n\n### LCP (Largest Contentful Paint)\n甚麼是 LCP 呢？ LCP翻譯是「最大內容繪製」，簡單來說就是網站最大的文字、圖片或是影片呈現到眼前所需要的時間，越快越好，Google只測試網站最大的那個內容，以一般網站首頁來說，第一個被掃到的很可能就是形象大圖，或是首頁形象影片，這些內容的優化就變得非常重要，也是影響網站速度的重要原因。 \n\n原出處: [網站速度- SEO優化的重要項目](https://www.da-vinci.com.tw/tw/seo-speed)\n\n### Priority\n我們應該要在每個 page 中設定它的 Largest Contentful Paint (LCP) element，使 Next.js 能夠優先 loading 它，提升 LCP。\n```diff\nimport Image from 'next/image'\n\nexport default function Home() {\n  return (\n    <>\n      <h1>My Homepage</h1>\n      <Image\n        src=\"/me.png\"\n        alt=\"Picture of the author\"\n        width={500}\n        height={500}\n+       priority\n      />\n      <p>Welcome to my homepage!</p>\n    </>\n  )\n}\n```"},{"title":"Mosh React Native Course Note","url":"/2022/03/28/Mosh-React-Native-Course-Note/","content":"\n# Mosh - React Native 課程筆記\n\n## 目錄\n\n+ [Ch1. Getting Started](#ch1.-getting-started)\n+ [Ch2. Fundamental Concepts](#ch2.-fundemental-concepts)\n+ [Ch3. Layout](#ch3.-layout)\n\n## Getting Started\n\n### 建立 React Native 專案\n\n```console\nnpm install -g expo-cli\nexpo init myApp\n```\n\n### Vscode - Extension\nReact Native Tools: 可以讓我們在 vscode 裡面 debug 我們的 App\n\n### 使用模擬器\n\nandroid emulator: \n\n1. 下載 android studio\n2. 下載完後，從 Actions 中選擇 AVD (Android Virtual Device) Manager \n3. 選擇 Create Virtual Device\n4. 選擇裝置 (建議選擇有 Play Store 的裝置)\n5. 選擇裝置 OS (建議選擇第二個，為最新且穩定的版本)\n6. 下載完後選擇剛剛下載的版本，然後命名\n\n這樣就建立完成一個 android emulator \n\n### 執行 React Native Project (android emulator)\n\n1. 在 cmd 中輸入: `npm start`\n2. 在開啟 android emulator 後，於 cmd 選擇 _open android_\n\n接下來就會在 android emulator 上下載並執行我們的\n程式\n\n### 使用實際手機測試 (android)\n\n1. 從 App Store 下載 _Expo Go_\n2. 在 cmd 中輸入: `npm start`\n3. 用 _Expo Go_ 內建的 QR Code 掃描器，掃描螢幕上的 QR Code (手機跟電腦要用同個網路)\n\n_(搖晃手機可以開啟 developer menu)_\n\n### 將 APP 發布到網站上\n\n1. 在 npm start 執行 App 後，可以從 cmd 點開 localhost 連結，開啟網頁\n2. 從網頁內點 publish or republish project\n3. 在 cmd 裡面登入 expo project 的帳號密碼\n\n## Ch2. Fundamental Concepts\n\n### Component\n+ `<View/>`: 跟 div 差不多\n+ `<SafeAreaView/>`:  排除掉會被手機擋住的地方\n+ `<Text/>`\n```jsx\n<Text numberOfLines={1} onPress={handlePress}>Hello World!</Text>\n```\n+ `Image`\n```jsx\n// 使用內部圖案\n<Image source={require('./assets/icon.png')}/>\n// 使用外部圖案 - soucre 接收物件\n<Image\n  fadeDuration={100} // fade 100ms\n  blurRadius={5}\n  source={{\n    width: 200,\n    height: 300,\n    uri: \"https://picsum.photos/200/300\",\n  }}\n/>\n```\n+ `<TouchableWithoutFeedback/>`, `<TouchableOpacity/>`, `<TouchableHighlight/>`: 讓圖片能夠點擊\n```jsx\n<TouchableHighlight onPress={() => console.log(\"Press!\")}>\n  <Image\n    source={{\n      width: 200,\n      height: 300,\n      uri: \"https://picsum.photos/200/300\",\n    }}\n  />\n</TouchableHighlight>\n```\n+ `<Button/>`\n```jsx\n<Button\n  color=\"orange\"\n  title=\"Click Me!\"\n  onPress={() => console.log(\"Clicked\")}\n/>\n```\n+ `Alert`: (function) 跳出詢問視窗 \n```jsx\nAlert.alert(\n  \"Alert title\", \n  \"message\", \n  [\n    // Alert 中的選項\n    { text: \"Yes\", onPress: () => console.log(\"Yes\") },\n    { text: \"No\",  onPress: () => console.log(\"No\")  },\n  ]\n)\n```\n+ `Platform`: (function) 偵測os\n```jsx\nalert(\"This Platform's OS is : \" + Platform.OS)\n```\n## Ch3. Layout\n\n+ 獲得裝置方向: \n```jsx\n// 1. Dimentions.get(\"screen\")\nconsole.log(Dimentios.get(\"screen\"))\n// 2. use hooks (npm install @react-native-community/hooks)\nimport {\n  useDimensions,\n  useDeviceOrientation,\n} from \"@react-native-community/hooks\";\n// get orientation from hooks\nconst orientation = useDeviceOrientation();\nconst dimensions = useDimensions();\n```\n\n+ `flex` in style: `flex: 1` 代表全部, 0.5 代表一半"},{"title":"Advanced CSS and Sass Course Note","url":"/2022/03/28/Advanced-CSS-and-Sass-Course-Note/","content":"\n紀錄於 Udemy 上由 _Jonas Schmedtmann_ 推出的 _Advanced CSS and Sass: Flexbox, Grid, Animations and More!_ 課程筆記。\n\n## Directory\n+ [CSS Specificity](#css-specificity)\n+ [CSS Tips](#css-tips)\n    - [Make background image have a gradient color](#1-make-background-image-have-a-gradient-color)\n    - [Make image have a cool shape](#2-make-image-have-a-cool-shape)\n    - [Make box be placed at the center of the parent element](#3-make-box-be-placed-at-the-center-of-the-parent-element)\n    - [Make a cool animation](#4-make-a-cool-animation)\n+ [SASS](#sass)\n\n\n## Concept\n### CSS Specificity\n\nIn css, `!important` have the most highest weight, and the other selector weight order is:  \n\n`inline-style` > `id` > `class` > `type-selector`\n\nWe can calculate the count from the high-order to the low-order selectors. Compare which selector have a higher weight. \n\n> Pseudo class have the same weight as class selector\n\nex.\n```css\n/* (inline, id, class, type) */\n\n/* (0, 1, 2, 2) */\n#nav div.pull-right a.button {\n  background-color: orangered;\n}\n\n/* (0, 1, 2, 1) */\n#nav a.button:hover {\n  background-color: yellow;\n}\n```\nIn this example, when we hover the button, the `background-color` will still being yellow. Because the upper selector total weight is higher than the selector which have `hover`. \n\n### Set the root font-size to `%`\nWe can set the root font-size in `html` tag. But we should set the `%` font-size rather than specific value. If the user's device has increased the default root value, we set the root font-size with specific value. It will not make the web views font-size change.\n\n```css\nhtml {\n  /* font-size: 10px */\n  font-size: 62.5% \n}\n```\n\n## CSS Tips\n### 1. Make background image have a gradient color\n\nGive `background-image` multiple values, the first value will be on the upper layer, the second value will be on the lower layer. We can make a color on the upper layer then set its color to a little bit transparent, so we can see the lower-layer image.\n\n```css\n.header{\n  background-image: linear-gradient(to right bottom, #7ed56fc0, #28b485be), url(\"../img/hero.jpg\");\n}\n```\n\n### 2. Make image have a cool shape\n\nMDN: [clip-path](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path)\n\nUse `clip-path` and `polygon` to set top、top-right、bottom-right、bottom-left point's location, then it will create a cool shape.\n\n```css\n.header {\n  clip-path: polygon(0 0, 100% 0, 100% 75%, 0 100%);\n}\n```\n\n### 3. Make box be placed at the center of the parent element \n\nSet `position: relative` in the parent element, then set position `absolute` to the box. Use `transform` to make the box at the center.\n\n```css\n.box {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n```\n\n### 4. Make a cool animation\nWe can use `keyframes` to create an animation with a specific name. After creating an animation, we can add `animation-name` and `animation-duration` to an element. Also, we can add the `animation` property to combine the above two properties. (By default animation will start when the CSS is loaded)\n\n> For the browser performance, it's best to only animate two different properties `opacity` and `transform`.\n\n```css\n.heading-primary-main {\n  /* animation-name: moveInLeft; */\n  /* animation-duration: 1s; */\n  animation: 1s moveInLeft;\n}\n\n@keyframes moveInLeft {\n  0% {\n    opacity: 0;\n    transform: translateX(-100px);\n  }\n  100% {\n    opacity: 1;\n    transform: translateX(0);\n  }\n}\n```\n\n#### animation-delay  \nWe can use `animation-delay` and `animation-fill-mode` to make an order of animations. \n\n**animation-fill-mode**:   \n**[reference](https://ithelp.ithome.com.tw/articles/10200393)**  \n\nanimation-fill-mode is used to set the view before / after the animation begin / finish.\n\n\n```css\n.btn-animated {\n  /* animation-delay: 0.75s; */\n  animation: moveInBottom 0.5s ease-out 0.75s;\n  animation-fill-mode: backwards;\n}\n```\n\n### SASS\nSass is a CSS pre-processor, an extension of CSS that adds power and elegance to the basic language. It's like we pass a Sass code to a Sass compiler, then it will be compiled to the CSS code.\n\n> SASS have **Sass syntax** which don't have curly brackets & **SCSS syntax** which have curly brackets.\n\n\n#### install\n`npm install node-sass --save-dev`\n\n#### compile\nadd script in `package.json`\n\n```json\n\"scripts\": {\n  \"compile:sass\": \"node-sass sass/main.scss css/style.css --watch\"\n}\n```\n\n#### variable\n```scss\n// define color variables\n$color-primary: #f9ed69;\n$color-secondary: #f08a5d;\n\nnav {\n  margin: 10px;\n  background-color: $color-primary;\n}\n```\n\n#### nesting\n```scss\n.navigation {\n  list-style: none;\n  // use nesting \n  li {\n    display: inline-block;\n    // define a psuedo class\n    &:first-child {\n      margin: 0;\n    }\n  }\n}\n```\n\n#### mixin\nIt's like `function` in css, use `@mixin` to define a function and `@include` to call this function.\n```scss\n@mixin style-link-text($color) {\n  text-decoration: none;\n  text-transform: uppercase;\n  color: $color;\n}\n\n.btn {\n  @include style-link-text(#fff);\n}\n```\n"},{"title":"Mosh redux course","url":"/2022/01/22/Mosh-redux-course/","content":"\n> 內文提到的程式 / 檔案紀錄在 github 內: [link](https://github.com/aleetsaiya/mosh-redux-starter)\n\n## 目錄\n+ [redux 架構](#redux-架構)   \n+ [dispatch, subscribe, getState](#dispatch-subscribe-getstate)  \n+ [Extensison](#extension)  \n+ [Multiple Reducers](#multiple-reducers)  \n+ [Middleware](#middleware)  \n+ [Testing redux application](#testing-redux-application)\n\n\n## redux 架構\n- action: 是什麼動作，帶了什麼資料\n```js\n{\n  type: 'deposit' // 什麼動作\n  payload: 10 // 附帶的資料\n}\n```\n- reducer: switch case 的 function，負責處理 action 的邏輯\n- dispatch: 派發給 action 給 reducer\n- store: 包含 state 以及 reducer，並在更新 state 後會通知 UI 重新渲染\n\n### 建立順序: \n1. 建立 reducer，需要 currentState, action 作為參數，根據不同的 action types 來更新 store 中的 state 並回傳\n2. 建立 store，需要 reducer 作為參數，為主程式接口，負責處理主程式發出的 `dispatch`, `subscribe`, `getState` 等動作\n3. 主程式對 store 進行 `dispatch`, `subscribe`, `getState` 等動作\n\n## dispatch, subscribe, getState\ndispatch: 根據不同的 action 來更新 store 中的 state  \nsubscribe: 參數為一 `function`，代表當 store 中的 state 更新時，需要做的事情  \ngetState: 獲得當前 store 中的 state\n\n## 檔案:\n> 課堂中各檔案的意思\n### src folder: \n+ `index.js`: 發出 dispatch, subscribe, getState 的檔案\n+ `reducer.js`: 建立 reducer\n+ `store.js`: 建立 store\n+ `customStore.js`: 親手建立簡單版的 store 內部\n+ `actionTypes.js`: 統一管理 reducer 處理的各種 action type，為 actionTypes 的接口\n+ `actionCreater.js`: 協助送出 dispatch 的細節\n\n### duck-pattern\n使用 duck-pattern 的結構時，會把 actionCreater, actionTypes, reducer 三個檔案合併放在同一個檔案裡\n```diff\nsrc folder:\n- bugs\n- |-- actionTypes.js\n- |-- actionCreater.js\n- |-- reducer.js\n+ bugs.js\n```\n\n## Extension\n> 介紹到的 redux extension\n### Redux DevTools: [link](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=zh-TW)\n\n使用時要在 create store 加上參數:\n```diff\nconst store = createStore(\n  reducer,\n+  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n);\n```\n參考: [redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension#1-with-redux)\n\nRedux Toolkit:\n```bash\nnpm install @reduxjs/toolkit\n```\n\n使用 redux toolkit 可以幫助我們建立之前手動建立的 `reducer`、`actionTypes``、actionCreater` 以及 `createStore`。\n\n`createStore` :\n```js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport reducer from \"./reducer\";\n\nexport default function () {\n  // when use configureStore, we don't need to check redux devTool extension\n  return configureStore({ reducer });\n}\n\n```  \n\n原本的 actionTypes + actionCreater > `createAction`: \n```js\nimport { createAction, createReducer } from \"@reduxjs/toolkit\";\n\n// Action Creators + Action Types\nexport const bugAdded = createAction(\"bugAdded\");\nexport const bugResolved = createAction(\"bugResolved\");\nexport const bugRemoved = createAction(\"bugRemoved\");\n```\n`createActions` 會根據我們傳入的 `typeName` 回傳一個 function，執行這個 function 並傳入 `argument` 會收到\n```js\n{\n  type: typeName,\n  payload: {\n    // your argument\n  }\n}\n```\n原本的 reducer > `createReducer`:\n```js\nexport default createReducer([], {\n  // actions: function (event => event handler)\n  // added\n  [bugAdded.type]: (bugs, action) => {\n    bugs.push({\n      id: ++lastId,\n      description: action.payload.description,\n      resolved: false,\n    });\n  },\n  // resolved\n  [bugResolved.type]: (bugs, action) => {\n    const index = bugs.findIndex((bug) => bug.id === action.payload.id);\n    bugs[index].resolved = true;\n  },\n  // removed\n  [bugRemoved.type]: (bugs, action) => {\n    const index = bugs.findIndex((bug) => bug.id === action.payload.id);\n    bugs.splice(index, 1);\n  },\n});\n```\n\n也可以將三個合併再一起寫 (`createAction` + `createReducer`) > `createSlice`:\n```js\nimport { createSlice } from \"@reduxjs/toolkit\";\n\nlet lastId = 0;\n\nconst slice = createSlice({\n  name: \"bugs\",\n  initialState: [],\n  reducers: {\n    // actions => action handlers\n    bugAdded: (bugs, action) => {\n      bugs.push({\n        id: ++lastId,\n        description: action.payload.description,\n        resolved: false,\n      });\n    },\n    bugResolved: (bugs, action) => {\n      const index = bugs.findIndex((bug) => bug.id === action.payload.id);\n      bugs[index].resolved = true;\n    },\n    bugRemoved: (bugs, action) => {\n      const index = bugs.findIndex((bug) => bug.id === action.payload.id);\n      bugs.splice(index, 1);\n    },\n  },\n});\n\nexport const { bugAdded, bugResolved, bugRemoved } = slice.actions;\nexport default slice.reducer;\n\n```\n\n## Multiple Reducers\n<img width=\"573\" alt=\"Reducer\" src=\"https://user-images.githubusercontent.com/67775387/149883054-0b5d39c6-8cc6-468d-b60d-4d6c5b033882.png\">\n\n### combineRedcers\n建立多個 reducer 管理不同的 state，然後最後再將這些 reducer `combine`\n```js\nimport { combineReducers } from \"redux\";\nimport projectsReducer from \"./projects\";\nimport bugsReducer from \"./bugs\";\n\nexport default combineReducers({\n  bugs: bugsReducer,\n  projects: projectsReducer,\n});\n```\n\n### selector\n可以在每個 `reducer slice` 的檔案中增加 selector，幫助我們選擇特定的 state\n```js\n// Selector\nexport const getUnresolvedBugs = (state) =>\n  state.entities.bugs.filter((bug) => !bug.resolved);\n```\n\n利用套件 `reselect` 可以讓我們將 output 儲存起來，如果下一次 input 沒有變動的話，就使用上一次儲存的結果回傳\n```js\nimport { createSelector } from \"reselect\";\n// Memoization\n// when the input not change, use the output from the cache (do not recalculate)\n// here we use \"reselect\" (npm install reselect)\nexport const getUnresolvedBugs = createSelector(\n  (state) => state.entities.bugs, // output of this function will pass to the next function\n  (bugs) => bugs.filter((bug) => !bugs.resolved) // if the parameter \"bugs\" do not change, the bug filter won't execute, will use the result from the cache\n);\n\n```\n## Middleware\nmiddleware 是我們從 dispatch 到 root reducer 的過程中所添加的程式\n\n### create Middleware\n1. 建立一個 middleware 資料夾 (使用這個名稱命名資料夾，資料夾 icon 會是不一樣的 ⚡)\n2. 建立 middleware 檔案\n\n使用 `currying` 表示接收三個參數 ( `store`, `next`, `action` ) 的函數\n```js\n// next: next is the reference to the \"next middleware function\",\n// if this's the only middleware function we have, next is going\n// to be the reducer that is going to handle this action\nconst logger = (store) => (next) => (action) => {\n  console.log(\"store\", store);\n  console.log(\"next\", next);\n  console.log(\"action\", action);\n};\n\nexport default logger;\n\n```\n\n3. 於 createStore 的檔案內，增加 middleware (middleware: array of middleware)\n\n```diff\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport reducer from \"./reducer\";\n+ import logger from \"./middleware/logger\";\n\nexport default function () {\n  return configureStore(\n    { reducer, \n+      middleware: [logger] \n    }\n  );\n}\n\n```\n\n> 如果要在 middleware 傳入參數的話 (除了 store, next, action 的參數)，在 store 前面再加一個 param，並在 createStore 中的 middleware 傳入參數\n\n```js\n// in middleware file\nconst logger = (param) => (store) => (next) => (action) => {\n  console.log(param);\n};\n\nexport default logger;\n\n// in createStore file\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport reducer from \"./reducer\";\nimport logger from \"./middleware/logger\";\n\nexport default function () {\n  return configureStore({ reducer, middleware: [logger(\"my param\")] });\n}\n```\n\n### Thunk middleware\n\n平常我們 `dispatch` 時，我們只能 dispatch 一個 object，而 `thunk middleware` 就是透過 middleware 使我們達成 **\"不僅可以 dispatch object，還可以 dispatch 一個 function\"**。通常來說我們在製作一個 thunk middleware 時會需要傳 2 個參數，分別是 `store` 以及 `getState`，底下為自製一個 thunk middleware:\n\n```js\n// middleware/func.js\nconst func = (store) => (next) => (action) => {\n  // 如果 action type 是 function 的話，就執行這個 function 並傳入 dispaych 以及 getState\n  if (typeof action === \"function\") action(store.dispatch, store.getState);\n  // 不是 function 就繼續送往下一個 middleware\n  else next(action);\n};\n\nexport default func;\n```\n\n製作完 thunk middleware 後，將他加入至 store 中\n```js\n// store/configureStore.js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport reducer from \"./reducer\";\nimport func from \"./middleware/func\";\n\nexport default function () {\n  return configureStore({ reducer, middleware: [func] });\n}\n\n```\n\n除了上面自己做一個 thunk middleware，我們可以使用 [redux-thun](https://github.com/reduxjs/redux-thunk)。如果我們專案是使用 `redux toolkit` 的話，只需要在 configureStore 中的 middleware 內加入 `...getDefaultMiddleware()`，就可以使用他們做好的 thunk middleware。\n\n```diff\n// store/configureStore.js\nimport { configureStore, getDefaultMiddleware } from \"@reduxjs/toolkit\";\nimport reducer from \"./reducer\";\n- import func from \"./middleware/func\";\n\nexport default function () {\n  return configureStore({\n    reducer,\n-    middleware: [func]\n+    middleware: [...getDefaultMiddleware()],\n  });\n}\n\n```\n\nMore about thunk: [讓你的Action能作更多 — Redux-Thunk](https://medium.com/frochu/%E9%80%81%E8%AE%93%E4%BD%A0%E7%9A%84action%E8%83%BD%E4%BD%9C%E6%9B%B4%E5%A4%9A-redux-thunk-c07bc5488e48)\n\n### combine with API\n將 middleware 結合發送 api:\n\n1. 建立 action ( `createAction` ) 負責統一處理 action type:\n\n```js\n// store/api.js\nimport { createAction } from \"@reduxjs/toolkit\";\n\nexport const apiRequest = createAction(\"apiRequest\"); // 送出 api request 的 action\nexport const apiCallSuccess = createAction(\"apiCallSuccess\"); // request success 的 action\nexport const apiCallFailed = createAction(\"apiCallFailed\"); // request failed 的 action\n\n```\n2. 建立 middleware，用來處理當我們從主程式收到 `api dispatch` 時要做的事情\n\n```js\n// store/middleware/api.js\nimport axios from \"axios\";\nimport * as actions from \"../api\";\n\nconst api = (store) => (next) => async (action) => {\n  // 如果送出的 action type 不是 apiRequest，那就送至下一個 middleware 並跳出\n  if (action.type !== actions.apiRequest.type) {\n    next(action);\n    return;\n  }\n  // action type 是 apiRequest，把接收到的 action payload 提取出來\n  const { url, method, data, onSuccess, onError } = action.payload;\n  // 將原 dispatch (apiRequest) 繼續送往下一個 middleware / reducer\n  next(action);\n  try {\n    // 根據收到的 action payload，送出 request\n    const response = await axios.request({\n      baseURL: \"http://localhost:9001/api\",\n      url,\n      method,\n      data,\n    });\n    // 如果收到的 action payload 中沒特別設定 request success 的 action type 的話，就 dispatch 預設的 success action type\n    store.dispatch(actions.apiCallSuccess(response.data));\n    // 如果有特別設定 request success 的 action type，就依內容送出 dispatch\n    if (onSuccess) store.dispatch({ type: onSuccess, payload: response.data });\n  } catch (error) {\n    // request 失敗時，送出預設 error dispatch\n    store.dispatch(actions.apiCallFailed(error));\n    // 有特別設定 request error 的 action type，依內容送出 dispatch\n    if (onError) store.dispatch({ type: onError, payload: error });\n  }\n};\n\nexport default api;\n\n```\n\n3. 將 middleware 加入至 store 內\n\n```js\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport reducer from \"./reducer\";\nimport toastify from \"./middleware/toastify\";\nimport api from \"./middleware/api\";\n\nexport default function () {\n  // when use configureStore, we don't need to check redux devTool extension\n  return configureStore({ reducer, middleware: [toastify, api] }); // 加入 api middleware\n}\n```\n\n4. 主程式送出 api dispatch\n\n```js\nimport configureStore from \"./store/configureStore\";\n// 匯入統一接口的 api action type\nimport * as actions from \"./store/api\";\n\nconst store = configureStore();\nstore.dispatch(\n  actions.apiRequest({\n    url: \"/bugs\",\n  })\n);\n// 上面的程式碼拆解如下:\n// store.dispatch(\n//   {\n//     type: apiRequest.type,\n//     payload: {\n//       url: \"/bugs\"\n//     }\n//   }\n// )\n```\n\n( 後續程式碼還有再增加 loading 以及 cache feature，完整版直接看 `src folder` 內程式 )\n\n\n## Testing Redux Application\n### Automated Testing\n+ Uni tests\n+ Integration tests\n+ End-to-end tests \n\n`Uni test`: test the application without its external dependencies. (fast)  \n`Integration test`: slower than uni test, but give us more confidence.  \n`End-to-end test`: the most slowest, simple break the UI will break severals end-to-end test.  \n\n### Use Extension \n1. install \n\n```bash\nnpm install jest @types/jest @babel/core @babel/preset-env babel-jest --save-dev\n```\n\n2. create `babel.config.json` in root folder (cool file icon ⚡)  \n\n```js\n// in babel.config.json\n{\n    \"presets\": [\"@babel/preset-env\"],\n    \"plugins\": []\n}\n```\n3. create `tests` folder to store `spec` file\n\n4. create `testname.spec.js` in test folder ( 在名稱裡面有 `spec` 的，通常來說是一個 test file )\n\n5. 在 package.json 加入:\n\n```diff\n\"scripts\": {\n  \"start\": \"webpack-dev-server --config ./webpack.config.js\",\n+  \"test\": \"jest\"\n},\n```\n\n6. 執行 `npm run test`\n\n( `npx jest --coverage` 會建立 coverage 資料夾，可以打開 `index.html` 看哪些檔案被測試涵蓋 )\n\n### create test file\n常使用到的 function:\n+ `describe` (name, fn): 一系列的測試，像是一個 folder 名叫 `name` 的感覺\n+ `it` (name, fn): 一個名叫 `name` 測試\n+ expect(`thing`) 後面加 `toBe()`, `toHaveLength()`, `toEqual()`, `toContainEqual` 等\n\n```js\nimport { isEven } from \"./math\";\n\n// define a group of test\ndescribe(\"isEven\", () => {\n  // define a test: it (testName, testFunction)\n  it(\"sould return true if given an even number\", () => {\n    // Function under test (SUT)\n    const result = isEven(2);\n    expect(result).toEqual(true);\n  });\n\n  it(\"sould return false if given an odd number\", () => {\n    const result = isEven(1);\n    expect(result).toEqual(false);\n  });\n});\n\n```\n\n### Unit test: solitary test && social test\nsolitary test 測試單一檔案是否有正常運作，social test 測試多個檔案合起來有沒有正常，而這些都屬於 unit test\n\n> solitary test 可能會因為太 detail，所以一個小改動 test 就出現錯誤\n\nsolitary test demo: [link](https://github.com/aleetsaiya/mosh-redux-starter/blob/master/demo/solitaryTest.md)  \n\nsocial test demo: [link](https://github.com/aleetsaiya/mosh-redux-starter/blob/master/demo/socialTest.md)\n\nTesting File 最後完成版: [link](https://github.com/aleetsaiya/mosh-redux-starter/blob/master/src/store/tests/bugs.spec.js)\n\n","categories":["Front-end"]},{"title":"如何在 window terminal 增加 git bash","url":"/2022/01/20/window-terminal-增加-git-bash/","content":"\n## 添加 git bash\n1. 點 window terminal 分頁視窗旁的 向下按鈕，選擇 `設定`\n2. 新增設定檔 :\n```\n名稱: Git bash\n命令列: C:\\Program Files\\Git\\bin\\bash.exe\n圖示: C:\\Program Files\\Git\\mingw64\\share\\git\\git-for-windows.ico\n```\n\n儲存後就可以用 window terminal 的分頁增加一個 Git bash 了。"},{"title":"git reset commit","url":"/2022/01/18/git-reset-commit/","content":"## 想要去除已提交的 commit 怎麼辦\n使用 `git reset` 可以幫助我們清除之前的 commit，而 reset 又有分 `--mixed` ( default ), `--soft` 跟 `--hard`。\n\n`soft` 會保留暫存區的檔案 (`add` 完後的檔案)，我們打的程式碼還在。\n\n`mixed` 會將暫存區的檔案清除，我們打的程式碼也還在。\n\n`hard` 會直接回到指定的版本，中間打的程式碼就都清除了。\n\n```bash\n# 將暫存區檔案 (git add) 清除\ngit reset \n# 回到前一個版本並將程式碼保留在暫存區\ngit reset --soft HEAD~1 \n# 回到前一個版本並清除中間的程式碼\ngit reset --hard HEAD~1\n```\n\nMore: [【狀況題】剛才的 Commit 後悔了，想要拆掉重做…](https://gitbook.tw/chapters/using-git/reset-commit)"},{"title":"vscode 快捷鍵、主題、extension 記錄","url":"/2022/01/10/vscode-快捷鍵、主題、extension-紀錄/","content":"\n## 快捷鍵\n* `ctrl + D` > 選擇當前文字\n* `alt + 滑鼠點擊` > 一次操作多個地方\n* `shift + alt + 滑鼠拖曳` > 一次操作多個地方\n* `shft + alt + ↓` > 複製一行\n* `ctrl + shft + K` > 刪除一行\n* `ctrl + X` > 剪下一行\n* `li*3` > 一次建立3個`li`\n* `ctrl + shft + R` > Refactor ，將程式碼打包成 function \n\n\n## 主題\n* _Night owl_ : 熬夜仔深色系主題，focus 的地方很清楚，用起來蠻舒服的，也是我目前在使用的主題。\n* _Ayu Mirage_ : Mosh 推薦的主題，背景色相較 Night owl 淡了一點，可是整體配色很和諧。\n\n## Extension\n***colorize***\n能夠將 RGB、HSL 代表的顏色，其顏色直接顯示在 code 裡面。\n\n***material icon theme***\n讓 file name 前面，顯示檔案類型對應的 icon。\n\n***eslint***\n透過它能夠直接在 vscode 中檢查程式碼是否有符合 eslint 規則。\n\n使用 npm 下載 eslint:\n* 下載 eslint: `npm install eslint --save-dev`\n* 在 `package.json` 的 script 中加入以下指令: (備註省略)\n```json\n  \"scripts\": {\n    // 初始化 eslint\n    \"eslintInit\": \"eslint --init\",\n    // 使用 eslint 檢查程式碼\n    //  --ext 的意思是指定哪些檔案的意思\n    \"lint-check\": \"eslint --ext .js,.jsx src/component/\",\n    // 使用自動修補程式碼\n    \"lint-fix\": \"eslint --fix --ext .js,.jsx src/component/\"\n  },\n```\n\n***prettier***\n提供能夠讓程式碼更好看的功能。\n\n存檔後自動使用 prettier: \n* 於 vscode 中 file > preferences > [search: formatonsave]，然後勾起來\n* 於 vscode 中按 `ctrl + p`，然後輸入: `>format document with`，將預設改為 prettier\n\n***prettier eslint***\n參考: [VSCode Prettier 整合 ESLint 自動排版](https://wcc723.github.io/development/2021/04/11/vscode-eslint-prettier/)\n如果要結合 eslint 以及 prettier，先從 vscode 下載 `prettier eslint`，並將 `format document with` 設定預設改成 _prettier eslint_，再透過 npm 下載 `eslint`, `prettier` 以及 `prettier eslint` 。\n```cmd\nnpm install --save-dev eslint prettier prettier-eslint\n```\n\n***Discord Presence***\n讓 discord 顯示正在 coding 的 rich presence\n\n***Live Server***\nLaunch a development local Server with live reload feature for static & dynamic pages\n\n***Git Graph***\n讓我們能直接在 vscode 裡面就看到分支圖","categories":["Front-end"]},{"title":"可視化持股網站","url":"/2022/01/04/可視化持股網站/","content":"## 建置心得\n這一次嘗試使用 React 建立一個能夠將持股紀錄變成可視化的股票分析圖表，過程中複習了被我荒廢好一大段時間的 React，以及在 JS 中如   何使用 Promise、axios、localStorage ...，總之算是學習到蠻多新的東西，也重新恢復一下自己之前上過的課程記憶。\n\n而做到目前我覺得算是告一個段落，從最一開始只是因為很酷炫嘗試仿造其它人做的網站樣貌，到現在能夠請求 Yahoo Finance API 然後繪製出歷史績效圖，能夠靠自己做出來說真的也算是蠻感動的 (雖然對其他人來說這些可能沒什麼 XD)。 其實我一開始也沒有想到自己會做這些功能，有點像是一邊做的過程中一邊覺得自己還可以再哪邊改進，又有哪個部分我可以再額外新增一些東西之類的。\n\n底下是目前持股網站的樣貌:  \n\n![demo](https://user-images.githubusercontent.com/67775387/147832616-f3065e3e-ae48-447e-834f-72be17b9f503.jpeg)\n\n## 學習紀錄\n\n### ApexChart\n這個網站能夠有那麼多的製圖，主要都源自於 [ApexCharts](https://apexcharts.com/) 這個套件，在網站內可以看到的柱狀圖、圓餅圖、線圖都是用這個套件繪製出來的。雖然一開始用的不習慣，可是後來比較看得懂怎麼去使用了之後就覺得這個套件還真好玩 XD，像是可以更動 donut chart 中間的數值呈現方式，以及滑鼠觸碰給使用者帶來的回饋我都覺得好讚，這邊也記取一個教訓就是下次要好好看別人寫的 docs。\n\n### React-Icons\n這次建置的過程中有使用到 [React-Icons](https://react-icons.github.io/react-icons/) 提供的 Icons，使用方式很簡單，就照著官方網站的範例來去使用就可以了。比較要注意的是使用不同 Icons 的名稱可能會需要 Import 不同的位置，像是如果要 import 的名稱是 \"fa\" 開頭，就要 import react-icons 底下的 fa 資料夾 : \n```jsx\nimport { FaBeer } from 'react-icons/fa';\nclass Question extends React.Component {\n  render() {\n    return <h3> Lets go for a <FaBeer />? </h3>\n  }\n}\n``` \n而如果要 import 的是 \"ai\" 開頭，就會需要 `import {...} from 'react-icons/ai'`。\n\n### localStorage / sessionStorage\n在這個 APP 中，我原本是使用 localStorage 來儲存從 Yahoo Finance API 獲得的資料以及過去每一天的績效，後來我改成使用 sessionStorage 的原因是因為:\n\n> sessionStorage 會在關閉網頁後自動清除，而 localStorage 會一直儲存在網頁儲存空間內\n\nAPP 因為每一次重新開啟時都會需要使用者重新輸入 csv 檔以及透過 API 抓取當前股市價格，因此我覺得放在比較容易被清除的 sessionStorage 會比 localStorage 好。\n\n### setState 是 async\n這次在做的過程中讓我碰壁的是有時候我會需要在 `setState` 後直接去呼叫一個 function，又或者是在 setState 後立即使用 State 中的值，可是因為 setState 是 asynchronous，所以我立即去使用或是呼叫的話就會出現錯誤。網路上的解決方法是將 callback function 放在 useEffect 裡面，然後配合 useEffect 的參數來去控制次數。\n\n\n### JS: Date\n在計算過去每日的績效時，會需要從 startDate 遍歷到 endDate。在建置的過程中學到了一個方式來處理關於時間的遍歷 : \n```jsx\n// 開始時間 (2021-12-29)\nconst startDate = new Date('2021-12-29');\n// 結束時間 (2022-01-04)\nconst endDate = new Date();\nconst dates = [];\nfor(let d = startDate; d <= endDate; d.setDate(d.getDate() + 1)) {\n    dates.push(d.toLocaleString());\n}\n```\n## 總結\n之後說不定還會把這個持股網站再新增功能或是升級之類的，還在想說要不要加個 navbar 然後之後試著做一下後端讓使用者能夠紀錄之前匯入的資料，就不用每次都要將 csv 檔匯入進去 blah blah blah，雖然現在覺得目前功能就我自己來說已經足夠了啦。總而言之那些也是之後的事情，這篇記錄網站建置的文章也就到這邊差不多告一個段落。"},{"title":"leetcode 寫題記錄","url":"/2021/07/21/leetcode-筆記/","content":"\n## 序\n目前剛開始刷 leetcode，打算先把各種 `tag` 裡面 easy 的題目都刷一些然後再到 medium 刷，在這邊紀錄我在刷 leetcode 的心得。\n\n## Hash table\n想要降低時間複雜度的話，比起寫一個 `nested-loop` 時間複雜度為 O(n^2)，可以使用 `Hash table` 先將要使用到的值記下來，然後再對 Hash table 進行查找。這樣就能將時間複雜度降為 O(n)。\n\n## Two pointer\n在解 Two Sum II - Input array is sorted 這題的時候學到的技巧，對 array 的頭跟尾設定 `left` 以及 `right`，然後從兩側開始往中間夾 (移動 left 以及 right)，直到找出相符答案。\n\n```javascript\n// 設定頭尾指標\nlet l = 0, r = numbers.length-1;\n\nwhile(true) {\n    if (numbers[l] + numbers[r] === target)\n        return [l+1, r+1];\n    else if (numbers[l] + numbers[r] > target) \n        r --;\n    else if (numbers[l] + numbers[r] < target)\n        l ++;\n}\n```\n\n## Find Difference\n如果一個題目是要找兩個資料不同的地方的話，可以試著使用 xor 來加快運算時間以及減少記憶體使用量。像是 _leetcode 389. Find the Difference_ 這題要找兩個被打亂的字串相異的字元 ( t字串為s字串的打亂版再增加一個字元 )，就可以使用 xor 來找。\n\n```javascript\nvar findTheDifference = function(s, t) {\n    let res = 0, i;\n    for(i = 0; i < s.length; i++) {\n        res ^= s.charCodeAt(i) ^ t.charCodeAt(i);\n    }\n    res ^= t.charCodeAt(i);\n    return String.fromCharCode(res);\n};\n```\n\n## Binary Tree\n目前寫到的題目通常來說可以分成使用 `recursive` 或是 `iterator` 來解，`recursive` 的話看是要用 前序, 中序, 還是後序來去搞，`iterator` 的話就先創一個 stack，然後將子節點都放進去來去處理。\n\n```javascript\n// 後序 (postorder)\nconst stack = [];\nconst res = []; // 負責存 output value\nstack.push(root);\nwhile(stack.length > 0) {\n    const node = stack.pop();\n    res.unshift(node.val);\n    \n    node.left ? stack.push(node.left) : '';\n    node.right ? stack.push(node.right) : '';\n}\n```"},{"title":"hexo 備份","url":"/2021/07/11/hexo備份/","content":"\n本文參考 : \n[Hexo備份至GitHub](https://www.dazhuanlan.com/2019/09/24/5d89fc809d6bf/)\n[30 天精通 Git 版本控管 (25)：使用 GitHub 遠端儲存庫 - 觀念篇](https://ithelp.ithome.com.tw/articles/10140055)\n---------------------------------\n## 步驟\n\n```bash\ngit init\n# 建立新分支 'hexo' 並切換至 'hexo' 分支  \ngit checkout -b hexo\ngit add .\ngit commit -m 'init'\ngit remote add origin https://github.com/aleetsaiya/aleetsaiya.github.io\ngit push -u origin hexo\n```\n\n這邊 `git push -u origin hexo` 設定 `-u` 的話，我們之後要 `push` 或是 `pull` 時就不用加後面的 `origin hexo` 了，只要打 : \n```javascript\ngit pull\ngit push\n```\n\n更多詳細的內容可以至參考文章看。"},{"title":"Tomatoes Clock 製作心得記錄","url":"/2021/07/07/tomatoes-clock/","content":"\n## 前言\n因為在網路上看到 [The F2E](https://challenge.thef2e.com/) 的前端作品訓練，其中第一關是 Tomatoes clock 想說我也來做做看好了，雖然沒有版上大家練習做得那麼好看，但是就當作是給自己的一個挑戰順便練習一下 javascript。\n\n## Tomatoes Clock 介紹\nTomatoes Clock 就是我們花 25 分鐘專注在自己設定的事物上，然後給休息 5 分鐘，這樣可以讓我們一方面提升自己的工作效率，一方面讓我們擁有足夠的休息時間。而除了將時間分割成 25, 5 分鐘以外，也要先設定好自己在做一個事情可能會花費的番茄數，做完了之後再回頭看自己有沒有跟當初預期的番茄數差不多，有沒有在做的過程中浪費時間在其他瑣碎的事情上。\n\n## 製作過程\n那接下來就紀錄自己在做這個網頁版的番茄時鐘遇到的問題以及心得吧。\n\n作品網址 : [Tomatoes clock](https://aleetsaiya.github.io/clock/#)\n程式碼: [Github](https://github.com/aleetsaiya/PotatoesClock)\n\n### CSS\n因為練習量的不足，所以在 css 排版上花了很多時間( 雖然我做的排版已經很簡單了，還是花很多時間在一些基礎的東西上 ... )，然後這是自己第一次套用 bootstrap 搭配自己的做的作品，所以很多命名好像都跟 bootstrap 的命名方式衝突，花了一大筆時間在看為什麼自己的網頁會長成這樣，之後可能要多練習切版以及在套用 bootstrap 時的一些操作。\n\n而 navbar 切換不同 page 的動畫效果，我原本想說可以做那種 *\"page 在右邊就從右邊滑進來，在左邊就從左邊滑近來\"* 的那種感覺，但可能是因為自己 css 不夠純熟所以雖然一開始是做出來了，可是後來排版一直跑掉而且還要加新的 \"Record\" 頁面，所以後來就放棄改成全部都從左邊滑近來。雖然感覺效果也是很好啦但還是帶著一點小遺憾。最後就是覺得在不同裝置上都要顯示的好看真的很難 ... 。\n\n### Javascript\n因為之前有在 javascript30 使用到 Event Delegate，所以這次回想了一下然後就在 todo-list 上使用。概念就是比起把每一個子節點都綁定事件，直接在父節點綁定事件，然後根據 `e.target` 來去偵測它是誰。\n\n這次也自己實作了之前在 javascript30 上學習到的 **localStorage**，透過 localStorage 紀錄資料讓我們下一次進入同一個網址或著是重新整理，能夠獲得之前的資料。我這邊是利用 localStorage 來紀錄使用者的待作清單。\n\n然後原本覺得很簡單很快就能做完的時間倒數部分，單純的時間倒數倒是很快就做好了，可是配合 stop, start, 以及切換模式後就發現很多細節自己都沒有設定到導致很多 bug ，在這邊也是花了比自己預期還要久的時間。\n\n## 結語\n這次會做這個番茄終的想法真的很突如其來，不知道為什麼就開始做了的那種感覺，自己在做完之後也複習以及學到了一些新的知識，感覺還不錯！重點是自己做出來一個能看的東西真的很爽 ~ \n\n-----------------------------------------------------\n*2021/7/10 更新*\n\n後來在 javascript30 也有做到 *Count down timer* 。看完了之後發現我之前的寫法真的級醜無比，用了一大堆 global variable 然後命名也命名的很隨便，所以後來重新把 js 中的一些部分做了修改，盡量的讓自己的程式碼比之前的更好維護，然後也更有架構以及邏輯性。\n\n## 減少 Global variable\n\n要減少 Global variable 一開始還真的完全沒概念，所以上網查了一點資料。找到了這篇 [JavaScript best practices](https://www.w3.org/wiki/JavaScript_best_practices)，其中的 Avoid Global 單元中介紹到 **Module Pattern** ，大概就是使用 [IIFE (Immediately Invoked Function Expression)](https://developer.mozilla.org/zh-TW/docs/Glossary/IIFE) 將變數限制在 function 範圍內，讓外部不允許使用內部的變數。而我們也可以自己設定要 `return` 的值 (讓外部使用的值)。\n\nex. 程式碼內 tomatoes 部分\n```javascript\nconst tomatoes = (function() {\n    let tomatoesNumber;\n    function init() {\n        tomatoesNumber = parseInt(localStorage.getItem('tomatoesNumber')) || 0;\n        setTomatoes(tomatoesNumber);\n    }\n\n    function getTomatoes() {\n        return tomatoesNumber;\n    }\n\n    function setTomatoes(number) {\n        const tomatoesDisplay = document.querySelector('.tomatoes');\n        tomatoesNumber = number;\n        localStorage.setItem(\"tomatoesNumber\", tomatoesNumber);\n        tomatoesDisplay.innerHTML = `Total: 🍅 x ${tomatoesNumber}`;\n    }\n\n    return {\n        init: init,\n        getTomatoes: getTomatoes,\n        setTomatoes: setTomatoes\n    }\n})();\n```\n\n外部只能允許使用 `return` 內的 `init`, `getTomatoes` 以及 `setTomatoes`，而 `tomatoesNumber` 則沒辦法在外部使用。\n\n## 讓程式碼更好維護\n除了更新了一些原本亂命名的變數外，也盡量讓 function 的命名更容易看得懂，之後回過頭來看至少不會不知道自己在寫什麼東西。而因為剛看完 `Mosh` 的課程教學，裡面有一個部分是要存所有 error 情況，我記得他是用 `list` 裡面裝 `object` 並把一些錯誤訊息也放進去，所以這次也試著寫了差不多概念的。\n\n```javascript\n// Error Check\nconst errors = [\n    {validate: isStudy && name === 'study', message: '⚠️ \"Study\" is the current mode.'},\n    {validate: isRest && name === 'rest', message: `⚠️ \"Rest\" is the current mode.`},\n    {validate: leftTime === 0 && name === 'playpause', message: '⚠️ Change the mode to keep going !'}\n];\nconst error = errors.find(error => error.validate ? error.message : false);\nif (error){\n    toastify.options.text = error.message;\n    toastify.showToast();\n    return;\n}\n```\n\n像這樣子寫就比之前原本寫的還要清楚，錯誤的情況有哪些，相對應的錯誤訊息也很容易看出來，要增加錯誤情型也很好增加，而其它的像是有些設定可以寫在 html 的 `data-*` 裡面。之前原本不同 mode 的時間設定我是寫在 javascript 裡面，可是發現寫成 `data-name=\"study\"` 放在 html 裡面就好了，javascript 可以直接用 `dataset.name` 裡面將值取出來。\n\n## 總結\n使用 IIFE 來避免 Global variable 我真心覺得超舒服，跟之前的程式碼相比差了很多，這次只是第一次用之後再把相關的概念補足起來。"},{"title":"npm 套件管理","url":"/2021/07/05/npm-套件管理/","content":"\n## 參考 : \n+ [NPM Install 到底做了些什麼？node_modules 檔案結構 + 特性入門](https://ithelp.ithome.com.tw/articles/10191783)\n+ [從零開始: 使用NPM套件](https://medium.com/html-test/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B-%E4%BD%BF%E7%94%A8npm%E5%A5%97%E4%BB%B6-317beefdf182)\n+ [解開npm安裝包npm install命令的疑惑,區分--save和--save-dev](https://ppfocus.com/0/di8924d63.html)\n\n----------------------------------------------\n\n## 介紹\n當我們在 python 中使用 pip 下載一個套件時，那些套件會存在我們的電腦上，所以之後只要在任何一個 python 檔中寫 `import` ... 就可以直接使用那個套件了。而 npm 相較於 pip，他是把每個一個專案要使用的 lib 都裝在每個專案的 `node_modules` 底下，所以會出現\"同一個套件下載很多次的情形\"，而這樣也方便我們對不同專案使用不同的套件版本。\n\n## 指令\n1. `npm init` 會建立 package.json，紀錄我們要使用的套件。\n2. `npm install`  如果`install`後面沒加套件名稱的話， npm 會幫你把 package.json 上有寫然後你目前 node_modules 還沒下載的套件安裝下來。\n3. `npm install bootstrap` 如果後面有加套件名稱 (像是 bootstrap) 的話，npm 會把你指定的套件安裝到 node_modules ，然後在 package.json 裡面記錄你剛剛安裝的套件。\n\n因為 node_modules 檔案很大所以通常來說不會放上去 github repository，所以如果有一天有一個人從不同台電腦 clone 我們的 repository 的話 (不會包含 node_modules) ，這時他可以輸入 `npm install`，就可以將紀錄在 package.json 上需要用到的套件下載下來到自己的 node_modules 裡。\n\n_於 `npm install`後面加上參數 -g 的話不會將目標下載到 `node_modules` 裡面，而是會下載到我們自己的磁碟裡，`npm config get prefix`可以查看 global 下載到的位置_ \n\n### scripts\n在 package.json 檔案裡面，`scripts`欄位擺的的是平常我們會在 cmd 上打的指令，像是底下這段 scripts\n\n```json\n\"scripts\": {\n\"compile:sass\": \"node-sass sass/main.scss /css/style.css\"\n},\n```\n\n在 cmd 上輸入 `npm rum compile:sass` 的話，就等同於在 cmd 上輸入 `node-sass sass/main.scss /css/style.css`，意思是把 sass 資料夾裡面的 main.scss 編譯後存到 css 資料夾內的 style.css。\n\n_於 node-sass 後面加上參數 -w 的話會於 cmd 持續追蹤是否有更新 main.scss_ ","categories":["Front-end"]},{"title":"Mastering React 課程筆記","url":"/2021/06/14/React-筆記/","content":"\n## 建立 React Project\n```Bash\ncreate-react-app myapp\ncd myapp\nnpm start\n```\n## 使用 bootstrap\n```bash\nnpm install bootstrap\n```\nindex.js\n```javascript\nimport 'bootstrap/dist/css/bootstrap.min.css';\n```\n## 名詞介紹\n\n### JSX\n參考 : [Day02-React.js基本介紹(JSX)](https://ithelp.ithome.com.tw/articles/10216945)\n\nJSX 就如同把 HTML 利用 Javascript 表示出來的語法糖 ( `Syntactic sugar` )。\n\nex.\n```javascript\nconst element = <h1>Hello World</h1>;\n```\n\n使用 JSX 時需要注意的是，如果要使用變數的話需要加一個大括號 `{}`\n```javascript\nconst message = 'Hello World';\nconst element = <h1>{message}</h1>\n```\n\n而如果遇到多行 HTML 的情況下，要用一個括號把他們刮起來 `()`\n```javascript\nconst message = (\n    <div>\n        <h1>Title</h1>\n        <p>content</p>\n    </div>\n)\n```\n\n在 JSX 裡，class 要寫成 `className`\n```javascript\nconst message = <div className=\"title\">Title</div>\n```\n\n### Babel \n> 引用至 [React 生態系（Ecosystem）入門簡介](https://github.com/kdchang/reactjs101/blob/master/Ch01/react-ecosystem-introduction.md)\n\n由於並非所有瀏覽器都支援 ES6+ 語法，所以透過 Babel 這個 JavaScript 編譯器（可以想成是翻譯機或是翻譯蒟篛）可以讓你的 ES6+ 、JSX 等程式碼轉換成瀏覽器可以看得懂的語法。通常會在資料夾的 root 位置加入 .babelrc 進行轉譯規則 preset 和引用外掛（plugin）的設定。\n\n## Component\n一個網頁是由許多 Component 組成，每個 Component 檔在影片中都為 .jsx 副檔名，後來爬文後發現似乎使用 .js 或是 .jsx 都是可以的。\n\nhello.jsx\n```javascript\nimport React, { Component } from 'react';\n\nclass Hello extends Component {\n    state = {\n\n    }\n    render() {\n        return <h1>Hello World</h1>;\n    }\n}\n\nexport default Hello;\n```\n\nindex.js\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport Hello from './components/hello';\n\nReactDOM.render(<Hello />, document.querySelector('#root'));\n```\n\n其中 `state` 負責存每個 Component 的變數，而 `render` 會負責回傳需要顯示出的畫面。接下來再將 Component 由 `ReactDom.render()` 顯示在網頁上。(第一個參數為 component, 第二個參數為 html selector)\n\n### Arrow Function\n在 Component 中如果 function 中會用到 this 的話，建議使用 arrow function，不然 this 不會指向物件本身。\n```javascript\nsample() = () => {\n    console.log(this);\n}\n```\n\n### 更新 `state` 的值\n要更新 `state` 的值的話，如果寫\n```javascript\nstate = {\n    count: 0,\n}\n\nthis.state.count ++;\n```\n這樣是沒有用的。要使用 `setState` 來更新值\n```javascript\nthis.setState({ count: this.state.count + 1 });\n```\n\n## Composing Components\n> 組合多個 Components 至一個 Component 中 ( Component tree )\n\n### Pass Data\n在我們組合多個 Components 時，會一種強況是需要從上層 Components 傳送值到下層 Components ( Parent to Child )\n\nex. 我們要把值從 Counters.jsx 傳到 Counter.jsx\n\n```javascript\n// in counters.jsx\nrender() {\n    return <Counter key={counter.id} value={counter.value}/>\n}\n```\n這時候下層接收值的方式就是 `this.props`。( props 的意思就是 properties 的意思 )\n\n```javascript\n// in counter.jsx\nstate = {\n    value: this.props.value //接收 counter.value\n}\n```\n\n*課程中推薦 Debug 工具* : [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n\n### Raise and Handle Event\n因為每個 Component 裡的 `state` 都為 private 的 ( 只有 Component 本身可以訪問 )，所以當我們要從 Child 裡更新 Parent 值的時候會無法更新。像是 Counters 創造了 4 個 Counter，而 Counter 無法在 counter.jsx 內刪除自己本身，只能在 counters.jsx 中刪除。\n\n這時我們可以透過 Parent 將負責更新的 function 傳給 Child，這樣會變成 Child 呼叫更新 function 而更新的動作依然在 Parent 內。\n\n```javascript\n// in counters.jsx ( Parent )\n// 傳送 handleDelete\nhandleDelete = (counterId) => {\n    const counters = this.state.counters.filter(c => c.id !== counterId);\n    this.setState({ counters: counters });\n}\nrender() {\n    return (\n        <div>\n            {this.state.counters.map(counter => \n            <Counter  \n            onDelete={this.handleDelete} \n            key={counter.id} \n            value={counter.value}\n            id={counter.id}/>)}\n        </div>\n    );\n}\n```\n```javascript\n// in counter.js ( Child )\n// 呼叫 handleDelete\n<button  onClick={() => this.props.onDelete(this.props.id)} className=\"btn btn-danger btn-sm btn-danger m-2\">Delete</button>\n```\n\n### Functional Components\n如果一個 Component 沒有使用到 state 以及其它 function，就只包含 render return 的話，可以改使用 function 來代表一個 Component 而非 class。\n\n```javascript\nconst NavBar = (props) => {\n    return (...);\n};\n\nexport default NavBar;\n```\n\n### Lifecycle Hooks\n> 分別為 Mount, Update, Unmounting\n\n+ Mount Phase\nWhen instance created and insert to the DOM。\n呼叫: `constructor` > `render` (recursive) > `componentDidMount`\n\n+ Update Phase\nWhen the state of the props of the component get changed。\n呼叫: `render` > `componentDidMount`\n\n+ Unmounting Phase\nWhen the component remove from the DOM。\n呼叫:  `componentWillUnmount`\n\n## Routing\n這邊使用 `react-router-dom`\n```bash\nnpm install react-router-dom\n```\n### BrowserRouter\n將 Component 用 `<BrowserRouter/>` 包起來\n```javascript\nReactDOM.render(<BrowserRouter><App /></BrowserRouter>, document.getElementById('root'));\n```\n\n### Route\n`<Route/>` 會根據不同的網址而呈現不同的東西(Component)。`<Switch/>` 可以使 `<Route/>` 不會同時出現多個 Route Component 的情況。`exact` 用來確保網址完全與設定的 path 相同。\n```javascript\nclass App extends Component {\n  render() {\n    return (\n      <div>\n        <NavBar />\n        <div className='content'>\n          <Switch>\n            <Route path='/products' component={Products} />\n            <Route path='/posts' component={Posts} />\n            <Route path='/admin' component={Dashboard} />\n            <Route path='/' exact component={Home} />\n          </Switch>\n        </div>\n      </div>\n    );\n  }\n}\n```\n\n### Link\n而要跳轉網頁(更改網址)的話可以使用`<Link/>`。使用`<Link/>` 代替 `<a/>` 可以讓頁面不會重新整理，要注意的是原本的 `href` attribute 要改成 `to`。\n```javascript\nconst NavBar = () => {\n  return (\n    <ul>\n      <li> <Link to=\"/\"> Home </Link> </li>\n      <li> <Link to=\"/products\"> Products </Link> </li>\n      <li> <Link to=\"/posts/2018/06\"> Posts </Link> </li>\n      <li> <Link to=\"/admin\"> Admin </Link> </li>\n    </ul>\n  );\n};\n```\n\n### Redirect\n`<Redirect/>` 可以設定如果使用者到特定網址時，要重新導向哪一個網址。\n```javascript\n<Redirect from='/' to='/movies'/> //從 home 導向到 movies\n<Redirect to='/not-found'/> //如果 <Route/> 都沒符合的話，最後寫這行可以讓不符合的網址都導向 not-found\n```\n\n### Url Data\n在 `<Route/>` 設定網址時，可以設定變數然後傳送值。\n```javascript\n<Route path='movies/:id' component={MovieForm}/>\n```\n\nin movieForm.jsx\n```javascript\nconst MovieForm({ match }) => {\n  // 對應到上面的 /:id\n  return <h1>Movie Form {match.params.id} </h1>\n}\n```\n\n## Form\n為了讓 `input` 變數裡的值跟 `state` 裡的變數相連再一起，要先把 `<input>` 裡的 `value` 更改設定，讓 input 欄位裡顯示的值是根據 state 裡的值來顯示。\n```javascript\nstate = {\n  account: {\n    username: \"\",\n    password: \"\"\n  }\n}\n\n<input value={this.state.account.username} />\n<input value={this.state.account.password} />\n```\n\n`value` 設定完之後，要設定 `onChange` 追蹤使用者輸入好讓我們更改 `state` 裡的值。而為了使 hangleChange 知道要更改的 target，將兩個 input 設定 `name` attribute 來辨別。\n\n順序:\n1. 執行 render >> 第一次render ( input欄位為空 )\n2. 輸入字符 a >> 因為輸入 a，所以此時的 e.currentTarget.value 為 'a' ，呼叫 handleChange。( input欄位還是空的 )\n3. 執行 handleChange >> 呼叫 setState 更改 state 裡的值，呼叫 render\n4. 執行 render >> 因為重新 render 了一次，所以此時 input 欄位為 state 裡的值 'a'\n\n```javascript\nhandleChange = e => {\n    const account = {...this.state.account};\n    account[e.currentTarget.name] = e.currentTarget.value;\n    this.setState({ account });\n}\n\n<input value={this.state.account.username} name='username' onChange={this.handleChange}/>\n<input value={this.state.account.password} name='password' onChange={this.handleChange}/>\n```\n\n## Backend \n> 使用 `Json Placeholder` 來獲得後端資料\n\n因為 React 只是一個負責處理 UI 的 Library ，所以相較於其他的 Framework，React 可以使用自己喜歡的 api 來送出 http requests。\n\n常見的 API :\n+ Fetch API\n+ jQuery AJAX\n+ Axios\n\n影片中 Mosh 介紹如何使用 axios。\n\n### Promise\n參考: [卡斯伯的 Blog- Promise](https://wcc723.github.io/development/2020/02/16/all-new-promise/#%E9%97%9C%E6%96%BC-Promise-%E5%B8%B8%E8%A6%8B%E5%95%8F%E9%A1%8C)\n當我們使用 `axios` 對 backend 送出 asyn requests 時，我們會獲得一個 `Promise`，此時的 promise 還是 pending 階段 (事件已經運行中，尚未取得結果)，運行結束後會有兩種結果 resolved / rejected，分別對應 `promise.then()` 以及 `promise.catch()` ，而如果不想用這種方式寫的話可以使用 `await` 來獲得 Promise 的值。\n\n```javascript\nasync componentDidMount() {\n  // pending > resolved (success) OR rejected (failure)\n  const promise = axios.get('https://jsonplaceholder.typicode.com/posts');\n  const response = await promise;\n  this.setState({ posts: response.data });\n}\n```\n\n### post \naxios 中使用 `post` 的方法跟 `get` 差不多，只要再多加 `post body` 就好。\n\n```javascript\n// 增加一個 post data \nhandleAdd = async () => {\n  const promise = axios.post(apiEndpoint, {title: 'a', body: 'yo'});\n  const { data: post } = await promise;\n\n  const posts = [post, ...this.state.posts];\n  this.setState({ posts })\n};\n```\n\n### update\n```javascript\nhandleUpdate = async post => {\n  post.title = 'Updated';\n  // Calling backend to update\n  // axios.put(targetUrl, updateBody)\n  await axios.put(`${apiEndpoint}/${post.id}`, post);\n\n  // Update UI \n  const posts = [...this.state.posts];\n  const index = posts.indexOf(post);\n  posts[index] = { ...post }; // Create new object to cover the origin one\n  this.setState({ posts });\n};\n```\n\n### delete\n```javascript\nhandleDelete = async post => {\n  // Calling backend to delete\n  // axios.delete(targetUrl)\n  await axios.delete(`${apiEndpoint}/${post.id}`);\n\n  // Update UI\n  const posts = this.state.posts.filter(p => p.id !== post.id);\n  this.setState({ posts });\n};\n```\n\n### Optimistic Updates\n先更新 UI ，然後再 call api，如果 api 沒順利完成的話再重新變回之前原本的狀態。\n\n```javascript\n  handleDelete = async post => {\n    const originalPosts = this.state.posts;\n\n    // Update UI\n    const posts = this.state.posts.filter(p => p.id !== post.id);\n    this.setState({ posts });\n\n    // Calling backend to delete\n    try{\n      await axios.delete(`${apiEndpoint}/${post.id}`);\n      throw new Error(\"\");\n    }\n    catch (e) {\n      alert('Something failed while deleting a post!');\n      this.setState({ originalPosts }) // 原本的狀態\n    }\n  };\n```\n\n### Expected vs Unexpected Errors\n+ Expected (404: not found, 400: bad request) - CLIENT ERRORS\nDisplay a specific error message\n\n+ Unexpected (network down, server down, db down, bug)\n1. Log them\n2. Display a generic and friendly error message\n\n```javascript\n    try{\n      await axios.delete(`${apiEndpoint}/${post.id}`);\n    }\n    catch (e) {\n      if (e.response && e.response.status === 404)\n        alert('This post had already been deleted.');\n      else {\n        console.log('Loggin the error', e);\n        alert('An unexpected error occurred.');\n      }\n\n      this.setState({ originalPosts })\n    }\n```\n\n### 錯誤通知\n使用 `react-toastify` 可以讓錯誤通知變得很有質感。\n\n```bash\nnpm install react-toastify\n```\n\nimport 套件以及 css 樣式，並在 render 內加入 `ToastContainer`。\n\n```javascript\n// in app.js\nimport 'react-toastify/dist/ReactToastify.css';\nimport { ToastContainer } from 'react-toastify';\n\nrender() {\n  return(\n    <ToastContainer/>\n    // ...\n  )\n}\n```\n\n`ToastContainer` 是負責顯示 error message 的區域，而呼叫 error 的方式是 `toast`。除了使用 `toast.error()` 外，也可以用 `warning`, `success` ... 。\n```javascript\n// in httpSerive\nimport { toast } from 'react-toastify';\n\nif (error) {\n  toast.error('An unexpected error occurred.');\n}\n```\n\n### 錯誤追蹤\n因為 console.log 只會在自己的裝置上顯示，所以如果想要追蹤其他人的錯誤訊息的話，可以使用 [Sentry]('https://sentry.io/welcome/?utm_source=google&utm_medium=cpc&utm_campaign=9575834316&utm_content=g&utm_term=sentry&gclid=CjwKCAjwoZWHBhBgEiwAiMN66fWVuX2TYiCWVenqdC06GOHkiJ6AhzccGevG8VNXTbK6atw2ZP9PXhoCWaQQAvD_BwE'), 基本上就是照著教學方式進行操作，設定好 js 檔後當別人使用你的網站有錯誤訊息時，你可以看到他的 console 中出現的錯誤。\n\n## React Hook\n\n### useState\n`useState` 分別會會回傳一個變數的 value 以及設定那個變數至 `state` 的 function (setState)。\n```javascript\nconst [count, setCount] = useState(0); // count = 0, setCount = setState({ count:  })\nconst [name, setName] = useState('Alee'); // name = 'Alee', setName = setState({ name:  })\n```\n\n### useEffect\n用來執行 class component 中的 : \n+ componentDidMount\n+ componentDidUpdate\n+ componentWillUnmount\n會於每一次 render 的時候呼叫 `useEffect`\n```javascript\nuseEffect(() => {\n    document.title = title;\n\n    return () => {\n        console.log('Clean');\n    };\n});\n```\n\n### useContext\n在建立一個 React App 的時候很常會出現從很上面一個一個往下傳，傳到最底下的這種情況。\n\n像是假設現在階層是 A(B(C(D))) ，A 在最上面 D 在最下面，如果我要從 A 傳到 D 的話中間就要經過 B C，然後 B C 也要設定好要傳送的變數。\n\n而如果用 `Context` 的話我們可以把上面的階層變得像是這樣 A(`Context.Provider`(B(C(D)))，這樣子底下的 B C 可以不用設定要傳送的參數，D 也可以更具 `Context Provider` 收到傳送的值。\n\nin userContext.js\n```javascript\nimport React from 'react';\n\nconst UserContext = React.createContext();\n\nUserContext.displayName = \"UserContext\"; // 設定 Context 的名稱為 UserContext\n\nexport default UserContext;\n```\n\nin App.jsx\n```javascript\nimport React, {useState} from 'react';\nimport MoviePage from './MoviePage';\nimport UserContext from './userContext';\n\nexport default function Appp(props) {\n    const [currentUser, setCurrentUser] = useState({name: 'Alee', age: 21});\n    return(\n        <UserContext.Provider value={currentUser}>\n            <div>\n                <MoviePage/> \n            </div>\n        </UserContext.Provider>\n    );\n}\n```\n\nin MovieList.jsx\n> 中間 App 與 MovieList 相隔一個 MoviePage\n\n```javascript\nimport React, { useContext } from 'react';\nimport UserContext from './userContext';\n\nexport default function MovieList(props) {\n    const currentUser = useContext(UserContext);\n    return(\n        <div>\n            <span>Movie List {currentUser.name} {currentUser.age}</span>\n        </div>\n    );\n}\n```\n\n所以使用上大概就是 : \n+ 建立 Context\n+ 上層傳送值的 Component 使用 `Context.Provider` 傳送值\n+ 底層接收值的 Component 使用 `useContext` 接收值"},{"title":"python Selenium 操作","url":"/2021/06/10/python-Selenium-操作/","content":"## 前言\npython的selenium可以幫助我們爬取一些難爬的網頁(像是有使用動態載入的網頁)，也可以使用它來對網頁進行自動化的操作。這篇文章紀錄自己常用到的 `webdriver api`。\n\n-------------------\n## 下載\n+ selenium\n```bash\npip install selenium\n```\n+ webdriver\n[ChromeDriver – WebDriver for Chrome](https://chromedriver.chromium.org/)\n\n-----------------\n## 操作\n### 開始使用 selenium\n```python\nfrom selenium import webdriber\ndriver = webdriver.Chrome('...chromedriver.exe')\n```\n\n### 造訪網頁\n```python\ndriver.get('https://aleelive.com')\n```\n\n### 搜尋元素\n```python\ndriver.find_element_by_css_selector(\"input\") #搜尋第一個input標籤元素\n```\n\n```python\ndriver.find_element_by_css_selector(\"input[type='password']\")\n```\n\n### 獲得 cookies\n```python\ndriver.get_cookies()\n```\n\n### 點擊動作\n```python\nbutton = driver.find_element_by_css_selector('button')\nbutton.click()\n```\n### 輸入動作\n```python\ninput_field = driver.find_element_by_css_selector('input')\ninput_field.send_keys(\"你想輸入的資訊\")\n```\n\n### 清除輸入資訊\n```python\ninput_field.clear()\n```\n\n### 執行javascript\n```python\ndriver.execute_script(\"javascript程式碼\")\n# ex.\ndriver.execute_script('window.scrollTo(0, document.body.scrollHeight / 5)')\n```\n\n### 獲得頁面資訊\n```python\npage_source = driver.page_source\n```\n---------------------\n基本上比較常用到的 `webdriver api` 就是上面列出來的這些了。"},{"title":"Object-oriented Programming in JavaScript 課程筆記","url":"/2021/06/10/Object-oriented-Programming-in-JavaScript-課程筆記/","content":"\n# Javascript mastery series-2\n\n## 簡介\nMosh 的 Javascript 系列課程分別為 javascript mastery series-1 以及 javascript mastery series-2，這一篇為 javascript mastery series-2 的筆記。\n\n## 內容\n這份課程比起前一部 ( series-1 ) 的內容，更注重在介紹 Javascript Objected Orient Type ( OOP ) 的特性，而 series-1 與 series-2 兩部課程都沒有介紹到常用的 DOM 操作或是 Javascript 的實務應用，而是注重在講解 Javascript 的基礎觀念。\n- [x] Objects\n- [x] Prototypes\n- [x] Prototypical Inheritance\n- [x] ES6 Classes\n- [x] Modules\n\n## OOP 四個特性\n1. 封裝（Encapsulation）\n2. 抽象（Abstraction）\n3. 繼承（Inheritance）\n4. 多型（Polymorphism）\n\n## Object\n這部分的影片有一半以上跟 series-1 的教學影片一樣，所以這邊就打一些之前上過的或是比較沒印象的。\n### Private Properties\n如果不想要將Properties顯示在物件上進行操作的話，只要將變數用 `let` 宣告就可以了。\n```javascript\nfunction Circle(color){\n    this.color = color;\n    let radius = 10;\n    this.square = function(){\n        return Math.PI * radius * radius;\n    }\n}\n\nconst circle = new Circle('blue');\n\nfor(let property in circle){\n    console.log(property); //color, square\n}\n```\n### private property 讀取\n使用 Object.defineProperty 並使用 getter 讓新屬性只能讀取\n```javascript\nconst sw = new Stopwatch();\n\nfunction Stopwatch() {\n    let duration = 1.5;\n    Object.defineProperty(this, 'duration', {\n        get: function() {\n            return duration;\n        }\n    });\n}\n\nconsole.log(sw.duration);\n```\n\n### Object 操作練習\n寫一個 Stopwatch Object，start 能開始計算時間，stop 能停止計算時間，resrt 能重新設定時間，duration 為持續時間。\n```javascript\nconst sw = new Stopwatch();\n\nfunction Stopwatch() {\n    let srartTime, endTime, running, duration = 0;\n    \n    this.start = function() {\n        if (running)\n            throw new Error('Stopwatch has already started.');\n        \n        running = true;\n        startTime = new Date();\n    };\n    this.stop = function() {\n        if(!running)\n            throw new Error('Stopwatch is not started.');\n\n        running = false;\n        endTime = new Date();\n        const seconds = (endTime.getTime() - startTime.getTime()) / 1000;\n        duration += seconds;\n    };\n    this.reset = function() {\n        startTime = null;\n        endTime = null;\n        running = false;\n        duration = 0;\n    };\n    Object.defineProperty(this, 'duration', {\n        get: function() {\n            return duration;\n        }\n    });\n}\n```\n\n## Prototypes\n+ Prototype 就是一個 Object 的 Parent，而連接的方式為 `__proto__`。\n+ 同一個 Constructor Function 擁有同樣的 prototype。\n\n範例: \n\n<img src=\"https://user-images.githubusercontent.com/67775387/118945718-4b014f80-b988-11eb-961d-dc8210258e9d.png\" alt=\"prototype\" width=\"450\"/>\n\n```javascript\nfunction Circle(radius) {\n    this.radius = radius;\n\n    this.draw = function() {\n        console.log('draw');\n    };\n}\n\nconst circle = new Circle(10);\n```\n\nprototype 的相關文章 :\n+ [該來理解 JavaScript 的原型鍊了](https://blog.techbridge.cc/2017/04/22/javascript-prototype/)\n+ [你懂 JavaScript 嗎？#19 原型（Prototype）](https://cythilya.github.io/2018/10/26/prototype/)\n\n## Prototypical Inheritance\n### 如何實作 Prototype-based 的繼承 ? \n```javascript\nfunction extend(Child, Parent) { //傳入兩個Constructor function\n    Child.prototype = Object.create(Parent.prototype); //建立一個繼承 Parent 的空物件，放入Child prototype\n    Child.prototype.constructor = Child; // //因為原本的Child.prototype.constructor 被覆蓋掉了，所以重新設定 constructor function\n}\n```\nex. 讓 Circle Obejct 繼承 Shape Object\n```javascript\n//make Cicle inheritance Shape\n\nfunction Shape(color){ //Shape 的 Constructor function\n    this.color = color;\n}\n\nfunction Circle(radius, color) { //Circle 的 Constructor function\n    Shape.call(this, color); //代替super.color\n    this.radius = radius;\n}\n\nCircle.prototype = Object.create(Shape.prototype); //回傳一個繼承 Shape.prototype 的空物件，並放入Circle prototype\nCircle.prototype.constructor = Circle; //因為原本的Circle.prototype.constructor 被覆蓋掉了，所以重新設定 constructor function\n\nCircle.prototype.say = function() { //add function in Circle prototype\n    console.log('say');\n}\n\nShape.prototype.hi = function() { // add function in Shape prototype\n    console.log('HI');\n}\n\ncircle = new Circle.prototype.constructor(10, 'red'); //等同於 circle = new Circle(10);\nconsole.log(circle);\n\n// circle >> Cicle prototype >> Shape prototype >> Object prototype\n// radi,color >>  say: func  >>    hi: func     >>    toString... \n\n```\n### Mixin\n將不同 Object 的 Property 融合到一個 Prototype 中。\n```javascript\nfunction mixin(target, ...sources){\n    Object.assign(target, ...sources);\n}\n```\n\n範例:\n```javascript\nfunction mixin(target, ...sources){\n    Object.assign(target, ...sources);\n}\n\nconst canEat = {\n    eat: function() {\n        this.hunger--;\n        console.log(\"eating\");\n    }\n};\n\nconst canWalk = {\n    walk: function() {\n        console.log('walking');\n    }\n};\n\nconst canSwim = {\n    swim: function() {\n        console.log('swim');\n    }\n}\n\nfunction Person() {\n    this.height = 165;\n    this.weight = 55;\n}\n\nfunction Fish() {\n    this.length = 30;\n}\n\n\nmixin(Person.prototype, canEat, canSwim, canWalk);\nmixin(Fish.prototype, canEat, canSwim);\n\n\nlet person = new Person();\nfor (let property in person)\n    console.log(property);  // height, eat, swim, walk\n\nconsole.log('----------');\n\nlet fish = new Fish();\nfor (let property in fish)\n    console.log(property); // length, eat, swim\n```\n\n## ES6 Classes\nES6 的 `class` 只是原本 constructor function 的 syntax sugar，而要注意的地方是**class 不會 Hoisting**。\n\n```javascript\nclass Circle {\n    constructor(radius) {\n        this.radius = radius;\n    }\n    //prototype \n    draw() {\n        console.log('draw');\n    }\n}\n```\n\n### Static  method\n不用創立一個 instance 就可以直接使用的 method。\n```javascript\nclass Circle {\n    constructor(radius) {\n        this.radius = radius;\n    }\n    //prototype \n    static draw() {\n        return 'draw';\n    }\n}\n\nconsole.log(Circle.draw()); //draw\n```\n\n### 繼承直接 extends 就好\n要注意的地方是，如果 parents 中包含 constructor function，則需在 constructor function 中呼叫 `super` ，否則會出錯。\n```javascript\nclass Shape {\n    constructor(color) {\n        this.color = color;\n    }\n    move() {\n        console.log('move');\n    }\n}\n\nclass Circle extends Shape{\n    constructor(color, radius) {\n        super(color);\n        this.radius = radius;\n    }\n    draw() {\n        console.log('draw');\n    }\n}\n\nconst c = new Circle('red', 10);\n```\n\n### Module\n在 ES6 中，輸出一個 `class` 。\n```javascript\nconst _radius = new WeakMap();\n\n// Public Interface\nexport class Circle {\n    constructor(radius) {\n        _radius.set(this, radius);\n    }\n\n    draw() {\n        console.log('Circle with radius ' + _radius.get(this));\n    }\n}\n```\nES6 中 import 一個 class\n```javascript\nimport {Circle} from './circle';\n\nconst c = new Circle(10);\nc.draw();\n```\n\n## 後記\n上完光頭的 javascript 兩份課程後，對javascript的理解程度真的比以前還要深很多，只是因為裡面都沒包含那種實作小工具的練習，所以現在打算多做一些 javascript 的實作增加自己的熟練度，而觀念的話看完這兩部教學基本上就有基礎的觀念了。相較於前一部，*The Ultimate JavaScript Mastery Series - Part 2* 講的深蠻多的。\n"},{"title":"解決 hexo butterfly 主題 code-block highlight error","url":"/2021/06/10/解決-hexo-butterfly-主題-code-block-highlight-error/","content":"\n我將之前的markdown文章轉移至 hexo 後，發現雖然設定好了 code block 的語言，可是整個程式碼區塊還是只有白色，爬文後找到解決方法。\n\n根目錄/_config.yml : \n```yml\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace: ''\n  wrap: true\n  hljs: false\n```\n\nthemes/butterfly/_config.yml : \n```yml\nhighlight_theme: mac #  darker / pale night / light / ocean / mac / mac light / false\nhighlight_copy: true # copy button\nhighlight_lang: true # show the code language\nhighlight_shrink: false # true: shrink the code blocks / false: expand the code blocks | none: expand code blocks and hide the button\nhighlight_height_limit: false # unit: px\ncode_word_wrap: false\n```"},{"title":"使用requests抓取facebook影片留言","url":"/2021/06/10/使用requests抓取facebook影片留言/","content":"## 前言\n大家好，我之前有寫過使用selenium抓取facebook影片留言，只是因為selenium爬完之後感覺有點沒勁，再加上有前輩指導說使用 mbasic.facebook.com進行爬蟲會比較方便，所以這篇文章就誕生啦！雖然其實不是全部使用requests，在登入的步驟還是有用到selenium，但比起之前的版本還是快上好幾倍，如果有興趣的話歡迎各位往下看，馬上來介紹我是如何使用requests抓取facebook影片留言。\n\n## 整體架構\n步驟：\n+ 登入facebook\n+ 送出請求\n+ 解析留言\n+ 輸出csv檔\n\n其中登入facebook的部分我是使用selenium來完成的，原本其實是打算使用requests.Session()獲得cookies，可是不知道為什麼在測試了幾次之後，原本能成功獲得cookies卻突然不行了，所以最後還是使用selenium，之後找到原因可能會在修改。\n\n## 步驟\n### 登入facebook\n登入的步驟就是很直觀的使用selenium找到輸入欄位，並輸入自己的帳號密碼送出。\n```python\n#透過selenium登入獲得cookies\ndef login(self):\n    #driver設定\n    driver = webdriver.Chrome(self.driver_location)\n\n    #登入動作\n    driver.get('https://www.facebook.com/')\n    input_1 = driver.find_element_by_css_selector('#email')\n    input_2 = driver.find_element_by_css_selector(\"input[type='password']\")\n\n    input_1.send_keys(self.account)\n    input_2.send_keys(self.password)\n    driver.find_element_by_css_selector(\"button[name='login']\").click()\n    time.sleep(1)\n```\n### 從selenium獲得cookies\n登入完成之後，我們就要把剛剛登入成功的cookies給存下來，使用 driver.get_cookies() 獲得cookies後，再將獲得的cookies放入請求中。\n```python\n#獲得登入cookies\ncookies = driver.get_cookies()\n\ns = requests.Session()\n\n#將cookies放入session中\nfor cookie in cookies:\n    s.cookies.set(cookie['name'], cookie['value'])\n```\n### 送出請求\n因為剛剛已經獲得了cookies，所以現在加上headers後，就來送出請求。\n```python\n#headers\nheaders = {\n    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36',  \n}\n\nresponse = s.get(url, headers=headers)\n```\n### 解析留言\n\n這個部分真的把我搞得很頭痛，原本想說直接根據留言的class抓取留言內容，可是實測後發現class會隨著不同影片改變(ex. a影片class=”ab”；b影片class=”ae”)。所以後來我是使用正則表示法，根據留言內容的id來判別(留言內容id長度都為15~16，由數字組成)。\n\n使用正則表示法獲得每一則留言的id，再使用BeautifulSoup根據這些id來找出每則留言。(這是我第一次使用正則表示法，所以如果寫得很醜的話請見諒XD)\n```python\n#獲得每則留言html id\ncmid = re.findall('id=\"\\d{15,16}', response.text)\ncmid_list = []\nfor i in cmid:\n    ii = i.split('\"')\n    cmid_list.append(ii[1])\n\n#根據 id存每則留言\nsoup= BeautifulSoup(response.text, 'html.parser')\ncomments = []\nfor id in cmid_list:\n    comments.append(soup.find('div', id=id))\n\n#分析留言內容\nfor comment in comments:\n    name = comment.find('h3').text\n    #print(name, end=' ')\n    msgs = comment.select('div')\n    msgs_s = ''\n    for msg in msgs:\n        if not re.findall('讚 · 傳達心情', msg.text) and not re.findall('已回覆 · \\d+ 則回覆', msg.text):\n            #print(msg.text)\n            msgs_s += msg.text\n    dic = {}\n    dic['name'] = name\n    dic['msg'] = msgs_s\n```\n### 輸出csv檔\n輸出csv檔的話使用pandas DataFrame，將資料輸出到指定資料夾內。\n```python\n#輸出至目錄底下資料夾\ndef to_csv(self, dir_name):\n    out_dir = './' + dir_name\n    out_name = '留言內容.csv'\n    df = pandas.DataFrame(data = self.data)\n    if not os.path.exists(out_dir):\n        os.mkdir(out_dir)\n    fullname = os.path.join(out_dir, out_name)    \n    df.to_csv(fullname, encoding='utf_8_sig', index=False)\n    print('輸出至', dir_name, '資料夾')\n    print('輸出完成')\n```\n\n## 結語\n做完這個之後感覺自己的爬蟲實力有比之前還要進步，過程中學習到蠻多的，完成之後也覺得很有成就感，若是看完這篇文章希望對你有所收穫 ~ "},{"title":"JavaScript Tutorial for Beginners 課程筆記","url":"/2021/06/09/Mosh-Javascript-課程筆記/","content":"\n# Javascript mastery series-1\n\n> Mosh 的 Javascript 系列課程分別為 javascript mastery series-1 以及 javascript mastery series-2，這一篇為 javascript mastery series-1 的筆記。\n\n## 內容\n這部課程的內容基本上從最基礎的變數開始介紹，然後延伸介紹各種變數的特性以及使用方式。而 series-1 與 series-2 兩部課程都沒有介紹到常用的 DOM 操作或是 Javascript 的實務應用，而是注重在講解 Javascript 的基礎觀念。\n- [x] Primitive-type 與 Reference-type\n- [x] OOP\n- [x] Object, Array, Function\n- [x] Factory Function 與 Constructor Function\n- [x] Call-by-value 與 Call-by-reference\n- [x] Hoisting\n- [x] let 與 var 的差別\n- [x] this 的意思\n\n**Javascript mastery series-2** : [Javascript OOP 觀念](https://github.com/aleetsaiya/Blog/issues/18)\n\n## ES6\nECMAScript (簡稱 ES6)，Javascript 語言新一代標準，一般是指 ES2015 標準。\n\n參考：[JavaScript ES6 介紹](https://www.fooish.com/javascript/ES6/)\n\n## 變數型態\n`typeof` variable\n### primitives types\n+ number\n+ string\n+ boolean\n+ undefined\n+ null\n### reference types\n+ object\n```javascript\nlet person = {\n    name: 'ALEE',\n    age: 30\n};\n// dot notation\nperson.name = 'Alex';\n\n//bracket notation\nperson['name'] = 'Yo';\n```\n+ array\n> array 也是一個object\n```javascript\n//create array\nlet selectedColors = ['red', 'blue'];\n\n// add\nselectedColors[2] = 'green';\n\n// different type\nselectedColors[3] = 5\n```\n+ function\n> function也是一個object ...\n```javascript\nfunction square(number){\n    return number * number;\n}\n\nlet number = square(2);\n```\n\n## Operators\n+ `+`, `-`, `*`, `/`, `**`\n+ `==`,  `===`, `!==`\n```javascript\n/* strict equality (type + value) */\nconsole.log(1 === 1); //true\nconsole.log('1' === 1); //false\n\n/* lose equality (value) */\nconsole.log(1 == 1); //true\nconsole.log('1' == 1); //true\nconsole.log(true == 1); //true\n\n```\n+ `&&`, `||`\n```javascript\n//when a operand is truthy it returnd\nconsole.log(false || true); //true\nconsole.log(false || 'Mosh'); //\"Mosh\"\nconsole.log(false || 1); //1\n\n/*  Falsy   */\nundefined, null, 0, false, '', NaN\n\n// Truthy >> anything that is not Falsy\n\nlet userColor = undefined;\nlet defaultColor = 'blue';\nlet currentColor = userColor || defaultColor;\n\nconsole.log(currentColor); //blue\n```\n## Control Flow\n+ `if... else if ... else`\n+ `switch`\n```javascript\nlet role;\nswitch(role){\n    case 'geust':\n        console.log('guest user');\n        break;\n    case 'moderator':\n        console.log('moderator user');\n        break;\n    default:\n        console.log('Unknown User');\n}\n```\n+ `while`, `do ... while`\n> *do while loop至少會執行一次, while loop不一定會執行*\n\n+ `for...in`, `for...of`\n```javascript\nconst person = {\n    name: 'Alee',\n    age: 30\n}\n\nfor(let key in person){\n    console.log(key, person[key]);\n}\n\nconst colors = ['red', 'green', 'blue'];\n\nfor(let index in colors){ //for...in 指向property\n    console.log(colors[index]);\n}\n\nfor(let color of colors){ //for...of 指向items\n    console.log(color);\n}\n```\n\n## Object-oriented Programming (OOP)\n> 將物件作為程式的基本單位，如果一個function在object裡面的話，要把它稱之為 `method`。\n\n```javascript\n//Object-oriented Programming (OOP)\nconst circle = {\n    radius: 1,\n    location:{\n        x: 1,\n        y: 1\n    },\n    isVisible: true,\n    draw: function(){\n        console.log('draw');\n    }\n};\n\ncircle.draw(); //Method\n\n```\n\n\n### 變數命名方式\n+ *Camel Notation* : 第一個字小寫，後面的都大寫  `oneTwoThreeFour`\n+ *Pascal Notation* : 第一個就大寫 `OneTwoThreeFour`\n\n\n## 建立Object方式\n> 為了讓程式師在debug的時候不用一次改太多程式碼(很麻煩)，通常會使用底下兩種方式來建立`客製化的Object`\n\n\n\n### Factory Function\n呼叫function，回傳一個object。使用Pascal Notation命名\n```javascript\n// Factory Function\nfunction createCircle(radius){\n    return { //Object\n        radius, //等同於 radius:radius\n        draw(){\n            console.log('draw');\n        }\n    }\n}\n\nconst circle1 = createCircle(1);\nconsole.log(circle1);\n\nconst circle2 = createCircle(2);\nconsole.log(circle2);\n```\n\n\n### Constructor Function\n利用 `new`，建立一個空的物件，並在function中建立物件完整資訊(*this*)。使用Camel Notation命名\n\n```javascript\n//Constructor Function (Pascal Notation)\nfunction Circle(radius){\n    this.radius = radius;\n    this.draw = function(){\n        console.log('draw');\n    }\n}\n\nconst circle = new Circle(1);\n```\n**使用 *new* 時我們做了什麼?**\n1. 建立一個empty-object `{}`\n2. 根據 `new` 後面的 constructor function，function中的 `this` 會指向empty-object `{}`，使獲得 `properties`\n\n## Dynamic Object\n在javascript中，object中的properties是可以隨時增加或是刪除的。\n\n### 刪除property\n```javascript\nconst circle = {\n    radius: 1\n};\n\ndelete circle.radius;\n```\n\n### 檢查property是否存在\n```javascript\nconst circle = {\n    radius: 1,\n    draw: function(){\n        console.log('draw');\n    }\n};\n\nif ('radius' in circle)\n    console.log('yes')\n```\n\n### 複製object\n```javascript\nconst circle = {\n    radius: 1,\n    draw: function(){\n        console.log('draw');\n    }\n};\n\nconst hello = {\n    hello: 'yo'\n}\n\n// 複製object\n// const another = {};\n// for (let key in circle)\n//     another[key] = circle[key];\n\nconst another = {...circle, ...hello};\nconsole.log(another);\n```\n\n\n## Constructor\n每一個object都有一個 `constructor` 屬性，用來指向創立那個object的function。(前面提到的 *constructor function*)。\n通常我們在寫 *let x = {}* 的時候，就等同於 *let x = new Object()*\n```javascript\nlet x = {};\n//let x = new Object();\n\n//Constructor Function\nfunction Circle(radius){\n    this.radius = radius;\n    this.draw = function(){\n        console.log('draw');\n    }\n}\n\nconsole.log(x.constructor); // return \"Object\" function\nconsole.log(new Circle(1).constructor); //return \"Circle\" function\n\nlet s = ''\n// let s = new String();\nconsole.log(s.constructor); // return \"String\" function\n\nlet n = 10\nconsole.log(n.constructor); //return \"Number\" function\n```\n\n## call by value 跟 call by reference\n前面有提到，變數可以分成 *primitives type* 以及 *reference type*，這兩種最大的差別就是前者是 *call by value* ，而後者是 *call by reference*。\n\n+ ***call by value***\n\n兩個變數的記憶體位置，分別存放他們各自擁有的值。\n\n```javascript\nlet x = 10;\nlet y = x;\nx = 20;\nconsole.log(y); //10\n```\n\n+ ***call by reference***\n\n而call by reference的話，兩個變數的記憶體位置裡面存放的不是值，是***指向其它記憶體的位置***。\n```javascript\nlet x = {value:10};\nlet y = x;\nx.value = 20\nconsole.log(y); //20\n```\n## ES6 templates literals\n\n相較於原本的 string 使用 `\"\"` 包起來，這裡使用 ` `` `把字串包起來，可以解決平常使用字串會需要特殊處理的文字，像是要顯示 \n`\"` 這個符號的時候，使用 templates literals就不用特殊處理。\n```javascript\nconst another = `This is my\nfirst' message`;\n```\n\n使用 *${ }*，將變數放在字串中:\n```javascript\nconst name = 'Alee';\nconst message = \n`Hi ${name},\n\nThank you for your reply.\n\nby Alex.\n`\nconsole.log(message);\n/*\nHi Alee,\n\nThank you for your reply.\n\nby Alex.\n*/\n```\n\n## Array\n\n### 增加元素\n```javascript\nconst numbers = [3, 4];\n\n// End\nnumbers.push(5, 6);\n\n// Begining\nnumbers.unshift(1, 2);\n\n// Middle\n// 增加或是刪除都用這個api\nnumbers.splice(2, 0, 9, 9, 9) //(start, deleteCount, [items wanna add])\n\nconsole.log(numbers); // [1, 2, 9, 9, 9, 3, 4, 5, 6]\n```\n\n### 找尋元素\n*primitive type* 與 *reference type*的找尋方式不一樣\n\n+ ***primitive type***\n```javascript\nconst numbers = [1, 2, 1, 3, 4];\n\n// return -1 if not in array\nconsole.log(numbers.indexOf(1));\nconsole.log(numbers.lastIndexOf(1));\n\n// true or false\nconsole.log(numbers.includes(1));\n```\n\n+ ***reference type***\n```javascript\nconst courses = [\n    {id: 1, name: 'b'},\n    {id: 2, name: 'c'},\n    {id: 3, name: 'd'},\n];\n\n// 根據自己定義的function來找元素\nlet found = courses.find(function(course){\n    return course.name === 'c';\n});\n\nlet index = courses.findIndex(function(course){\n    return course.name === 'd';\n});\n\nconsole.log(found); //{ id: 2, name: 'c' }\nconsole.log(index); //2\n```\n\n### 刪除元素\n```javascript\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8];\n\n// End\nnumbers.pop()\n\n// Begining\nnumbers.shift(numbers);\n\n// Middle\n// 增加或是刪除都用這個api\nnumbers.splice(2, 1);\n```\n\n### 切割 / 合併陣列\n```javascript\nconst first = [1, 2, 3];\nconst second = [4, 5, 6];\n\nconst combine = first.concat(second); //[ 1, 2, 3, 4, 5, 6 ]\n\nconst combine = [...first, 'a', ...second, 'b'];\n/*[\n  1, 2, 3, 'a',\n  4, 5, 6, 'b'\n]*/\n\nconst slice = combine.slice(2); //[3, 4, 5, 6]\n```\n\n### 排序陣列\n```javascript\nconst numbers = [2, 3, 1];\n\nnumbers.sort();\nconsole.log(numbers); // [ 1, 2, 3 ]\n\nnumbers.reverse();\nconsole.log(numbers); //[ 3, 2, 1 ]\n```\n\n### 其它常用的 Array API\n```javascript\n//every\nconst numbers = [1, 2, 3];\nconst allPostive = numbers.every(n => n >= 0);\nconsole.log(allPostive); //true\n\n//some \nconst numbers2 = [-5, 0, -20];\nconst atLeastOnePostive = numbers2.some(n => n >= 0);\nconsole.log(atLeastOnePostive); //true\n\n//filter\nconst filtered = numbers.filter(n => n >= 0);\nconsole.log(filtered); //[1, 2, 3]\n\n//map\nconst items = filtered.map(n => '<li>' + n + '</li>');\nconsole.log(items); //[ '<li>1</li>', '<li>2</li>', '<li>3</li>' ]\n```\n\n\n## Function\n\n### 宣告方式\n\n+ ***Function Declaration***\n```javascript\nfunction walk(){\n    console.log('walk');\n}\n```\n\n+ ***Function Expression***\n```javascript\n// Anonynous Function Expression\nconst run = function(){\n    console.log('run');\n};\n```\n\n### Hoisting\n當我們使用 *Function Declaration* 的方式去宣告一個function時，javascript 會自動把這些 function 移到程式碼的最上面，而  ***Hoisting*** 的意思就是 javascript 把 function 移到最上面的過程。\n[Javascript Hoisting](https://github.com/aleetsaiya/Blog/issues/16)\n\n***程式碼的樣子***\n```javascript\nwalk();\n\nfunction walk(){\n    console.log('walk');\n}\n```\n\n***javascript執行***\n> 自動移到最上面\n```javascript\nfunction walk(){\n    console.log('walk');\n}\n\nwalk();\n```\n\n### Arguments\n每個 function 中都有 `arguments` 用來表示接收到的所有參數。\n```javascript\nfunction sum() {\n    let total = 0;\n    for(let value of arguments)\n        total += value;\n    return total;\n}\n\nconsole.log(sum(1, 2, 3, 4));\n```\n\n### Rest parameter\n除了用上面介紹的 `arguments` 來獲得所有參數外，也可以用 Rest parameters ( `...args` ) 獲得所有參數至一個陣列裡面。\n```javascript\nfunction sum(...args) {\n    console.log(args); //[ 1, 2, 3, 4 ]\n}\n\nsum(1, 2, 3, 4);\n```\n\n### default value of parameters\n在 ES6 中，可以透過底下語法來設定一個 Function 的預設值。\n```javascript\n// default value of parameter\nfunction interest(principal, rate=3.5, years=5) {\n    return principal * rate / 100 * years;\n}\n\nconsole.log(interest(1000));\n```\n\n### Getters and Setters\n當我們想獲得一個 function 的值，可是不想以呼叫 function 的方式，而是使用 properties 來獲得值得話，可以透過 `get` 來讓我們在 Object 外部直接呼叫 properties 來獲得值。\n```javascript\nconst person = {\n    firstName: 'Alee',\n    lastName: 'Tsai',\n    get fullName() {\n        return `${this.firstName} ${this.lastName}`\n    }\n};\n// 以property的方式\nconsole.log(person.fullName); \n```\n\n而 setters 能讓我們透過 property 的方式來去呼叫一個 function\n\n```javascript\nconst person = {\n    firstName: 'Alee',\n    lastName: 'Tsai',\n    get fullName() {\n        return `${this.firstName} ${this.lastName}`\n    },\n    set fullName(value) {\n        const parts = value.split(' ');\n        this.firstName = parts[0];\n        this.lastName = parts[1];\n    }\n};\n//設定 Object 中的 properties 值\nperson.fullName = 'A BaBa'\nconsole.log(person.fullName);  //A BaBa\n```\n\n### Error Handling\n用 `try...catch` 以及 `throw new Error( )`。\n```javascript\nlet check = function(value) {\n    if(typeof value !== 'string')\n        throw new Error('Not a string!');\n}\n\ntry{\n    check(1);\n}\ncatch (e) {\n    console.log(e); //Error: Not a string!\n}\n```\n\n## let 與 var 的差別\n在 ES6 之前，我們只能透過 `var` 來宣告一個變數；而在 ES6 之後，我們可以透過 `let` 以及 `const` 來宣告一個變數，而 `var` 與其它兩個宣告方式的差別為：\n> var 為 function-scoped => 以一個 function 來做為區隔單位\n> let, const 為 block-scoped => 以一個 block `{ }` 來做為區隔單位\n\n```javascript\nfunction test_let(){\n    for(let i = 0; i < 5; i++){\n        console.log(i);\n    }\n    console.log(i); //i is not defined\n}\n\nfunction test_var(){\n    for(var i = 0; i < 5; i++){\n        console.log(i);\n    }\n    console.log(i); //5\n}\n```\n\n## this 的意思\n`this` 在不同情況會指向不同的東西，有可能是 `object` ，有可能是 `window`，分別他們的方法：\n+ ***method in object -> object***\n+ ***general function -> global(window, global)***\n\n舉例:\n```javascript\nconst video = {\n    title: 'a',\n    f(){\n        console.log(this);\n    }\n}\n\nfunction movie() {\n    console.log(this);\n}\nvideo.f() // this指向video obj\nmovie() // this指向global window\n```\n\n***使用 arrow function 的話，`this` 會繼承 ( inherit ) 父親的 `this`***\n```javascript\nconst video = {\n    tags: ['a', 'b', 'c'],\n    showTags(){\n        this.tags.forEach(function(value){\n            console.log(this, value);\n        })\n    }\n}\nconst movie = {\n    tags: ['a', 'b', 'c'],\n    showTags(){\n        this.tags.forEach(value=>{\n            console.log(this, value);\n        })\n    }\n}\nvideo.showTags() // this 指向 global window\nmovie.showTags() // this 指向 object\n```\n\n\n### 改變 this 指向\n利用 `bind` 改變 this 指向的物件\n```javascript\nfunction movie() {\n    console.log(this);\n}\nmovie(); //global window\nconst m = movie.bind({title:'Nice movie'});\nm(); // {title: 'Nice movie'}\n```\n\n## 結語\n看完之後說真的幫助蠻大的，比起之前自己東找西找，我覺得有系統性的學習對我來說幫助比較大，而且它的課程也不會很貴 ( 我買一個月看到飽方案換算台幣 826元 ) ，課程裡面對基礎的東西以及觀念也介紹得很仔細，所以總結下來如果你也在找 Javascript 課程的話，我個人是蠻推薦光頭的課程。接下來 javascript mastery series-2 的筆記會放在另一份 issue。\n\n<img src=\"https://user-images.githubusercontent.com/67775387/116808493-ac918380-ab6b-11eb-8acd-4b4ebc260cbb.jpg\" width=\"500\"/>"},{"title":"m3u8格式介紹","url":"/2021/06/09/m3u8格式介紹/","content":"## m3u8格式\n今天在看文章的時候發現這個格式，就了解了一下關於 m3u8 檔到底是什麼 ，底下附上文章裡面介紹的很詳盡。\n\n參考 : [【全网最全】m3u8到底是什么格式？一篇文章搞定m3u8下载](https://zhuanlan.zhihu.com/p/346683119)\n\n通常來說在傳輸一個影片的時候，我們會把一個影片切成一片一片的來傳輸，這樣可以使我們的傳輸速度提高，也可以增加使用者體驗。假設我們切出來的影片為數個 `.ts` 檔，我們就需要一個文件來幫助我們將這些 ts 檔的下載位置存起來，讓網站能夠根據這個文件來獲得這些影片片段 ( `.ts`檔 )，而這份索引文件就是 `.m3u8` 文件。所以如果你今天想下載一個影片的話，可以按 `F12` 從 Network 找出 `.m3u8` 檔的封包，下載檔案後經過工具處理我們可以得到文件內 `.ts` 的下載鏈結，然後再根據這些鏈結將 ts檔 轉換為 mp4 檔就完成了。\n\n有興趣的可以看 : \n+ [m3u8-to-mp4.md](https://gist.github.com/tzmartin/fb1f4a8e95ef5fb79596bd4719671b5d)\n+ [利用ffmpeg合併m3u8串流影片，並且轉成MP4格式](https://shimeche.github.io/2017/04/13/%E5%88%A9%E7%94%A8ffmpeg%E5%90%88%E4%BD%B5m3u8%E4%B8%B2%E6%B5%81%E5%BD%B1%E7%89%87%EF%BC%8C%E4%B8%A6%E4%B8%94%E8%BD%89%E6%88%90MP4%E6%A0%BC%E5%BC%8F/)\n+ [How to Use VLC to Convert .M3U8 File to MP4 for Free](https://www.easefab.com/tutorial/vlc-convert-m3u8-to-mp4.html)\n\n如果是追求方便的話推薦使用 VLC ，ffmpeg 需要在 cmd 上進行操作。\n\n## 相關詞彙\n在使用 ffmpeg 或是 vlc 的時候，碰到一些之前沒看過的詞彙。\n### mux、demux\n參考 : [关于音视频的一些知识（demux、filter等）](https://my.oschina.net/jerikc/blog/476953)\n簡單來說 mux 就是影音合併，demux 就是將影音分離。\n### codec\n來自 coder 與 decoder ，就是編解碼器的意思。( ex. H.264 codec )\n\n## 操作過程\n我是使用 ffmpeg 來幫我將 m3u8 檔轉換為 mp4 檔的，參考的文件就是上面提供的 ffmpeg 相關文章。而自己操作下來會發現如果先將 m3u8 檔下載好，然後進行轉換的話會出現錯誤如下\n\n指令 : \n```bash\nffmpeg -i \"720p.m3u8\" -c copy file.mp4\n```\n錯誤訊息 : \n```Bash\nError when loading first segment '720p_000.ts'\n720p.m3u8: Invalid data found when processing input\n```\n\n修復方法 : \n只要將 m3u8 在地檔改成下載鏈結就解決了。\n```Bash\nffmpeg -i \"https://...\" -c copy file.mp4\n```"}]